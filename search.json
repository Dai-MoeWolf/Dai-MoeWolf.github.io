[{"title":"茉子的幻想乡奇遇（七）：场景切换和农田恢复","date":"2022-12-12T12:40:23.000Z","url":"/uncategorized/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%92%8C%E5%86%9C%E7%94%B0%E6%81%A2%E5%A4%8D/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["undefined",""]],"content":"实现一个场景切换管理类，使用异步加载的方式进行更加方便的封装，并实现切换场景，显示过场景Loading条面板，对重启游戏&amp;回到神社场景后进行农田的恢复 场景管理器首先我们自己封装一个场景管理器，用于统一的场景同步/异步加载，有很多时候，需要我们在切换场景时预加载，避免游戏时加载的卡顿，也在此手动进行GC管理，避免了自动GC造成的卡顿 可交互对象游戏中应当由许多的可交互对象，切换场景的可交互的大门，或者小屋内的箱子，这些箱子在玩家靠近后都会有一样的行为，就是出现可交互图标，然后具体的实现逻辑就有子类来实现 对于这个木箱来说，我们之前写好的木箱面板就可以接入了，我们的接口都已经写好了 因此，我们就泛化出一个基类，他们都拥有一个图标，和玩家交互的状态（这个是为了防止玩家在交互中时，重复触发交互），然后对于会切换场景的交互对象时，我们泛化出一个方法用于统一的切换场景，子类还可以调用时加入自己的回调函数 场景切换的目标点切换场景后的玩家设置点我们先预设好，这样就免得切换场景后，玩家的坐标在场景外面了，当切换场景时，我们就通过这个预设点设置玩家位置就好了 直接继承自写好的可交互对象基类，然后重写基类方法，设置好场景切换的目标点，这里由于是要进入木屋，那么为了避免木箱UI在游戏中加载造成卡顿就直接写在回调函数中预加载即可 Loading面板使用遮罩的方式做一个Loading条，根据场景管理器中的异步加载动态的修改面板上的信息 场景切换效果 农田恢复既然实现了场景切换，当我们切换场景后，原场景的农田就不复存在了，我们此时也应该让他在后台不断地计算每一块农田的生长情况，既然我们之前选择的协程的方式，但由于场景切换后，原有的协程就会被销毁了，所以我们使用在Update中计算每一块农田的情况，但是如此多的Update，由于Unity的调用方式问题，会造成许多的性能消耗，所以要尽可能少的使用Update，如果要使用，最好将Update都写在一个公共的游戏对象中 公共Mono类为此，我们实现一个公共的Mono类来统一执行所有的Update，而需要进行Update的对象，使用事件监听的方式，在公共的Mono对象上Update中执行这些订阅者的回调函数 MonoController Mono管理器 事件中心类上面的代码使用了这个事件中心，它可以统一的管理所有的事件，发布事件 农田管理类修改玩家信息类，添加农田信息 那么最重要的是能有一个类统一的管理农田，并计算好每一个土地上作物状况，即使切换场景后也能够准确计时，每次种植就会存入字典，然后在公共的Mono的Update中计算时间 对于之前的CropObj，我们修改一下 加入一个函数重载PlantCrop，让其接收到剩余时间，依旧使用协程的方式完成作物剩下的生长阶段 场景切换后的恢复切换回神社场景时，在场景切换中就执行恢复的方法 重进游戏后的恢复多存档的博客留给下一期 在游戏数据管理器中，选择了存档后就会加载进指定的存档，根据玩家数据来恢复农田 "},{"title":"茉子的幻想乡奇遇（六）：种田功能的实现","date":"2022-09-30T04:15:28.000Z","url":"/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E7%A7%8D%E7%94%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["茉子的幻想乡奇遇","/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/"]],"content":"使用协程控制每一个单元格上的作物生长，利用对象池控制的获得道具提示信息而避免频繁GC，配合InputSystem的作物、物品、农田与玩家交互 农田设计农田的背景使用TileMap制作，在每一个种植的点位上添加一个空物体，这就是实际的作物对象存在的位置 每一个作物对象上有一个SpriteRenderer用于显示作物的图标，并且身上有一个触发器，用于判断玩家是否靠近了作物，根据当前作物状态来判度可交互图标的显示，头顶有两个对象，负责显示作物种植的时间条和一个可交互图标，并且初步对作物的成员变量设计 当然手动来给这些种植点位添加对象的做法很费时间，直接编写一个编辑器工具，用于一键生成这些作物对象 种植功能与面板UI当玩家靠近一个空的种植点位时，就显示可种植的交互图标，此时按下功能键E就应该显示当前背包中有的种子，然后选择一个种子种下，对于时间条而言，一共有六个子图片，而作物生长时，会经过四个状态，每个状态的图片，根据种子的种植时间来判断并动态的更新，在每个作物中使用Update和计时器的做法，相当的浪费性能（由于Unity通过反射来获取程序集，每一个对象上都单独的使用Update，会造成很多额外开销，可以使用事件监听和公共的一个Update来统一执行所有需要Update的游戏对象）我在此就使用协程，根据种子的种植计算下一次等待更新作物状态的时间 既然玩家进入一个空闲作物的触发器要显示一个种子选择面板，那么自然还是要拼一个UI，还是使用神奇的Grid Layout Group组件，对于一个小格子，身上有一个显示种子的Image控件，和一个显示数量的TextMeshPro控件 当玩家将鼠标移入一个格子时，应该弹出粽子的信息和种植所需的时间的面板，这里就想到来给有信息的格子添加EventTrigger实现这些功能，首先是种植面板的逻辑 然后是格子本身 最后是种子信息的显示面板UI和逻辑 在作物边交互打开种植面板时，将自身作物对象信息通过面板传递到单个格子，当这个格子按下时就会执行这个作物格子的PlantCrop函数，并且将格子自己显示的种子信息也传入进这个作物对象，就完成了信息的传递和循环 效果物品会根据时间变化自己的形态和更新时间条，这都是基于协程完成的，当玩家靠近一个空闲的种植点后，点击功能键E就会显示种植面板，当鼠标移动到种子上，就会弹出对应的种子信息 作物成熟与收获重构ItemData表当作物成熟时收获作物，就会在周围创建一些当前作物的实际对象，供玩家拾起，此时，修改一下当初的ItemData，添加linkId字段，将种子和成熟的作物联系在一起，这样作物成熟时，就可以根据自己的linkId直接找到对应的作物 场景上的Item当作物收获后，应该在周围创建一些实际的道具来收获，每一个物品对象的构成如下，物品自身的图片，一个提示图标，还有一个进入物体的触发器后显示的tipsKey 那么就可以实现了物品对象脚本，在玩家按下功能键F后，就执行背包面板的AddItem2InventoryByItemObj函数，他是通过拾起物品的方式添加物品到背包，此外还有一个AddItem2Inventory函数，它通过ItemInfo来添加物品到背包 背包面板脚本，增加了一个字典，用于物品的增减判断逻辑(通过id就可以判断是否存在此物品)，拾取物品时，这里会呼出一个提示面板，由于这个面板会被频繁唤起，所以使用了对象池，在下一小节种会说明 如此，就可以写出完整的作物脚本了，并且使用协程，在收获作物后，在周围随机创建3-6个成熟的作物 效果当作物成熟时，时间条不再显示，而作物的形态也是成熟的形态，此时玩家靠近作物，就会出现一个可收获的图标 如果玩家按下功能键E，便会通过协程在周围随机地方创建随机3~6个成熟作物对象，并且靠近对象就会出现按键F提示 对象池与获得物品提示面板由于拾取物品后，会出现一个提示信息面板，用于告知玩家获得了什么道具，如果背包满了，也会提示相应的信息，这个消息面板更像是一个消息弹窗，他会上移，然后逐渐透明消失，当如果反复的新建游戏对象，又在它消失后删除，这些内存中的碎片并不会被删除，而是在0代内存满后进行一次GC，此时就会造成游戏卡顿，而频繁的新建、删除对象会导致频繁的GC，对象池将这些不需要的游戏对象存起来，当再次要使用的时候直接取出来再利用就行了 对象池 提示信息提示信息面板就是一个TextMeshPro，上面挂载了一个CanvasGroup组件用于控制自身的透明度，当自身被激活时，就计时执行将自己的位置上移并且渐隐 效果当玩家收获物品后，就可以将物品添加到背包，并且出现以下的提示信息，这些提示信息不会被删除，而是存入对象池，等待下次被使用 至此，种田功能就做好咯Ciallo～(∠・ω&lt; )⌒☆"},{"title":"茉子的幻想乡奇遇（五）：玩家控制和2D混合树","date":"2022-09-29T12:52:22.000Z","url":"/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%8E%A9%E5%AE%B6%E6%8E%A7%E5%88%B6%E5%92%8C2d%E6%B7%B7%E5%90%88%E6%A0%91/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["茉子的幻想乡奇遇","/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/"]],"content":"使用TileMap制作了第一个游戏场景，使用了新的InputSystem制作玩家输入、控制，以及2D混合树来控制角色不同方向的序列帧动画 配置InputActions对于目前游戏的需求，暂时拟定一些按键，并生成一个C#文件，以后在任意地方判断玩家的输入也可以用得到，在项目设置中使用的是新老输入系统的都是用，这样之后就可以使用Cinemachine来实现摄像机跟随主角移动，这个插件只能是旧输入系统 玩家控制脚本给玩家添加一个PlayerInput组件，这里使用Invoke C# Event的方式来监听输入事件，当然也可以使用直接生成的C#文件来监听，编写一个脚本用来控制玩家， 考虑到角色序列帧动画只有上下左右四种移动方向，所以让玩家只能有这四个方向的移动，但是这里配置的Action Type是一个Vector2的Value类型，那么就取其分量，并且同时只取一个值，就是说玩家在竖直移动时按下了水平移动，那么就就行水平移动而不竖直移动，使用两个旗标来表示两个不同的输入信号，使用一个枚举类型来表示当前按下类型，这样就可以保证优先响应后输入的信号 对于多个方向的运动，最好解决的方法就是使用混合树，混合树能大幅度降低动画机的复杂性，过多的状态之间转换由混合树自己来判断，省去了繁琐的判断 这里由于主角有四个方向的运动，那么自然就有四个方向的idle，最后面朝的方向，就是停止输入后显示的idle方向，这里就使用两个混合树来做，idle使用的一个ID混合树，由四个不同的值（0、0.3、0.6、1）来表示当前的方向，这个方向在控制脚本中（如上面脚本101行）具体移动方向的时候被确定，根据水平/竖直方向输入的数值的正负来确定具体的方向 对于Move混合树，他是一个2D的FreeForm混合树，由于素材太少，没有跑动的序列帧动画，这里就是用加速Walk动画播放速度来替代 具体移动中对动画机的参数的改变都在上面的脚本中，然后使用Cinemachine配合一个限制范围的碰撞器来 效果gif格式演示可能很卡顿，实际上是相当的丝滑Ciallo～(∠・ω&lt; )⌒☆ "},{"title":"茉子的幻想乡奇遇（四）：木箱和背包物品的互换","date":"2022-09-20T02:06:51.000Z","url":"/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9C%A8%E7%AE%B1%E5%92%8C%E8%83%8C%E5%8C%85%E7%89%A9%E5%93%81%E7%9A%84%E4%BA%92%E6%8D%A2/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["茉子的幻想乡奇遇","/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/"]],"content":"实际上是两个容器的数据交换 思路之前在游戏存档设计中使用了PlayerData类型currentPlayerData字段在选择了对应存档时，保存了当前存档的玩家数据，PlayerData中的成员属性，其中保存了背包数据和箱子数据，这下实施两个容器的数据交换就很方便了，但是使用List存物品有一个小缺点，没有办法通过ItemInfo的id来获取到对应的ItemInfo，在之后会将他转存为字典，以&lt;id,itemInfo&gt;来转存，通过id就可以获取到对应的ItemInfo，而ItemInfo存储了Item的id和数量，这就是要通过木箱——背包的界面操作完成的数据交换的实质 木箱面板采取了和背包面板一样的制作思路，由BoxPanel访问到currentPlayerData的box和inventory数据，然后根据数据动态的刷新面板，而其中背包和木箱的小格子通过BoxPanel每次刷新时，通过BoxPanel传入的itemInfo来设置自己的物品图片和物品数量，此外，点击小格子会出现一个移动物品面板，可以在其中设置移动的数量，只有被BoxPanel初始化，拥有itemInfo的格子才可以点击出这个移动物品面板 木箱UI由BoxPanel管理两个容器的View，具体操作逻辑由移动面板来控制 移动物品面板UI这个面板由小格子初始化时，由添加的点击事件创建，这个上面的数值和按钮的显示和禁用，按照itemInfo的进行严格限制，以从木箱移动到背包为例 全部移动后，背包的这个物品不可以超过99，若超过，则只移动背包这个物品到达99的数量 这个物品有多少，增加到当前物品的数值后，增加按钮不可交互 减少按钮最小到达1，到达1后不可交互 按数值部分移动物品，背包这个物品不可以超过99，当预计背包当前物品 + 移动的物品数量 = 99时，增加按钮不可交互 背包和木箱最多容纳20个种类的物品，当达到上限后，不可以增加种类，只允许两边都拥有的物品，在以上规则之下移动 逻辑BoxPanel这里用字典转存了一遍ItemInfo，目的就是在配置移动规则时更加方便，由于是引用类型，修改其中的ItemInfo也会使得currentPlayerData中的数据修改 和背包面板一样，由于还没有游戏开始的逻辑，这里手动获取一下玩家存档数据，以后有了就删除这里的代码 物品格子考虑到背包和木箱的格子有很多的相同元素，这里就将共有的部分泛化为父类，然后让背包和木箱的格子继承此类，每个拥有ItemInfo的格子，会给自己添加一个点击事件，点击后将ItemInfo传入移动物品面板，使用一个枚举ContainerType来区分当前物品时木箱还是背包，这里有一个ResetItem函数，就是说当前物品从这个容器移动到另一个容器时，当前的格子物品数量为0，则需要从玩家的对应物品容器中移除掉最后一个物品的格子（因为使用Remove方法，List会自动将后面的索引往前挪一位，此时最后一位格子在BoxPanel执行UpdateBoxPanel时，由于做法是玩家容器有多少物品就加载多少格子，并达不到移动前的最后一格，而这最后一个的就不会被刷新，所以需要手动删除），并且需要将这个格子的事件触发器移除，并将图片和数量设置为初始状态 由于父类中实现了大部分功能，子类只需要重写一下添加事件触发器的监听即可 对于木箱而言，木箱在面板的下侧，那么移动物品面板应该出现在上方，而背包在面板的上侧，则移动物品面板应该出现在下方，这样就避免面板到屏幕外面去了，这就是两个子类重写的目的之一 移动物品面板根据在拼UI的时候给出的操作约束，这里的代码量就非常的多，要考虑各种情况，避免移动物品出现bug和提升代码鲁棒性，这里的判断分支特别多，而且从一边移动到另一边的逻辑是完全一样的，完全可以提取成一个私有函数来减少代码重复，由于只有两个ContainerType，还是就这么写了，具体的数据操作写在按钮的监听事件中，而SetButtonInteractable专门判断/设置按钮的可交互 效果 只能移动两个 对面容器满了，并且这是一个新的种类，所以不能移动 对面容器满了，这个物品在对面也有，所以可以移动，而且只能移动使得对面容器这个物品达到上限99 至此，一个木箱的完整功能就做好咯(ﾉ◕ヮ◕)ﾉ*.✧"},{"title":"茉子的幻想乡奇遇（三）：Excel表配置数据和背包系统","date":"2022-09-18T05:17:13.000Z","url":"/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Aexcel%E8%A1%A8%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%92%8C%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["茉子的幻想乡奇遇","/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/"]],"content":"使用Excel配置物品数据，并转换为Json文件，初步设计了玩家数据 使用Excel配置数据单机游戏中配置数据的方法有很多，比如xml，json甚至是PlayerPrefs，用这些方式来配置数据相当不方便，需求总是一变再变的，比如一个物品以后要多加一个属性，使用xml和json修改是相当痛苦的，json中的数组元素每一个都要手动的添加一个属性和数值，而对于Excel来说就是加一行/列的事情，而且Excel可以使用自定义函数更加方便数据的配置，且一切数据一目了然 当然Excel的缺点就是不能像xml和json那样直接反序列化成一个实体类，当然可以自己写工具来实现，这里我就直接将Excel转换为Json文件再来将Json反序列化成一个类 ItemData数据类与容器类对于游戏中每一个物品，都有同样的属性，将物品的所有属性配置后，放入容器类Items的列表中，而Excel配置的，就是这个容器类的列表，它是所有物品数据的集合 Excel配置规则要将Excel正确的读取，就要按照规则进行数据配置 第一行：字段名 第二行：字段类型 第三行：主键（如果容器是字典的话就可以用这个当作键） 第四行：字段说明（相当于配置Excel的注释） 表名：容器类的集合字段名（这里是info） 编辑器模式工具这里采用的方法是在编辑器模式下，将Excel转换成Json放到StreamingAssets文件夹，运行时读取加载到内存就好，这里需要使用Excel的API，找到Excel的官方dll类库文件导入到项目就行 然后再编辑器窗口上点击开发工具 → Excel表转Json，就可以将配置好的Excel转换为Json了 ItemDataMgr数据管理类有了Json之后就是要将Json读进内存转换为实体类，然后提供一些接口给外部使用，这里就是将读出来的物品容器，再Init函数中重新放入字典（因为Json对字典的键有要求，最好是string，而使用int作为字典的键写进Json还是会变成字符串） 这里思考一下玩家数据如何存储自己的物品呢，将一个个Item直接作为实体类存入玩家的背包，对内存的消耗很大，所以化繁为简直接存储物品id加物品数量，这里的GetItemInfo函数就是传入id时再获取到对应Item，这样玩家需要存储的数据就变少了 多存档玩家数据PlayerData数据类对于未来可能会增加的需求，可能这一下子难以考虑周全，比如以后会保存角色的位置之类的，这里尽可能的写，ItemInfo就是玩家实际存储的道具信息，而不去存储多余信息的Item，PlayerDataInfo就是多存档的玩家数据列表 GameDataMgr存档数据管理类根据playerDataInfo的数据，在主界面的GameDataPanel中列出来，然后选中数据后通过GetPlayerDataInfo函数得到存档currentPlayerData，如果开始新游戏则调用AddNewPlayerData函数创建新的游戏存档 背包系统背包面板背包的面板比较复杂，首先是物品区域，其中的ItemGrid使用Grid Layout Group组件将每一个物品格子规则摆好，其中每一个物品格子又有两个组件，一个是显示物品图片，一个是显示物品数量 物品格子每一个物品格子根据数据来显示自己的图片和右下角的物品数量，如果这个格子存在数据，就给自己添加一个点击事件，点击后显示一个使用/丢弃按钮，根据物品的类型，判断这个物品是否能使用（种子不能直接使用），并在物品描述中显示自己的信息描述，如下图： 逻辑脚本点击按钮出现的点击按钮只能存在一个，而且它本身也是一个面板，所以继承写好的单例模式面板基类，这里具体的使用和丢弃功能，在以后再来实现，当传入的item种类是种子的时候，将自己的使用按钮interactable设置为false 物品格子通过事件触发器来给自己添加点击事件（显示物品描述，和显示按钮面板，并传入Item信息给按钮面板），根据从背包面板中传入的item信息来更新自己的imgItem和txtNum 背包面板这里不在Awake中调用ShowMe主要是由于Awake的执行顺序是随机的，如果物品格子没有被Awake，则这里调用物品格子的InitInfo会空引用报错，这里的ShowMe函数中，由于暂时没有获取玩家数据的途径，这里手动执行获取一下玩家数据的函数，之后还是使用currentPlayerData来获取当前的玩家数据，待后续完善了存档面板逻辑之后，再过来删掉这句代码就好 至此，背包系统的大体就做好了(人´∀｀)｡ﾟ+"},{"title":"茉子的幻想乡奇遇（二）：对话功能的实现","date":"2022-09-13T13:13:59.000Z","url":"/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%AF%9D%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["茉子的幻想乡奇遇","/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/"]],"content":"使用.txt文本文档按规则存储对话文本，使用单例模式对话管理类读取文件并显示到UI 制作思路实现对话功能的方式有很多，起初的想法就是比如用xml或者是json在里面写对话文本，然后将其读取转成一个数据类，通过这个数据类来访问对话文本，但是用手写xml和json要注意格式，而我想比如文案能更好的把注意力放在写对话剧情上，当然也可以写一些小工具，将写好的对话文案转成xml或者json文件，这里就不那么麻烦，直接写在一个文本文档里面，使用文件流读取就好 对话面板单例模式UI面板基类使用PureMVC能很好的降低模块的耦合性，但是使用起来真的很繁琐，这里就让面板继承写好的UI面板基类，让对应的管理类来管理单例面板的数据，仍然将Model层、View层、Controller层分离，而且使用起来更加的轻松方便 对话面板拼UI面板注意下分辨率自适应就好了，面板上的角色立绘和文字，之后都会使用对话管理器根据文本文档动态的改变，立绘的透明度在后面会进行动态的修改 然后就是初始化过后隐藏自己就好，在管理器中通过单例来访问这个面板，并且可以设置控件上的数据 对话数据和数据管理类对话数据文本自己定义一个简单的规则，按照规则书写就好，之后读取文本就按照这个规则来读取，我想的就是第一行就是初始化面板的时候NPC的名字，我们可以根据这个名字来加载面板NPC位置的图片，第二行开始就是对话了，每一个对话使用&gt;开头，用于区分不同的对话，每一句对话使用:区分说话的角色名字和对话内容，当然规则完全可以按照自己的喜好来 对话数据类有了数据当然就需要对应的一个数据类来存储里面的信息，使用一个字符串数组来存储里面所有用&gt;分开的字符 对话管理类将数据读到数据类，并且将内容显示到UI，就是对话管理类干的事情了，一个管理类自然就是一个单例模式，而对话文本肯定不止有一个，所以需要一个字典将数据类存起来，当要使用某一个对话数据时，使用字典就方便访问了，这个类在构造的时候就需要读取我们写好的所有对话文本，并把它们存入字典，写对话数据文本时，我们规定好了格式，根据规定的格式来分割文本就好 这里使用StreamingAssets文件夹存放文本，要注意字典需要判断一下是否存在文本了，因为编辑器模式下，他会在编辑器的StreamingAssets和运行状态的的StreamingAssets都取找读取，所以会读到两个一模一样文本 读到了数据，那自然就是要把数据显示到UI，每一句对话都是由:分割的，前面的是角色名，后面的是对话内容，这样就看分别显示到UI的对应位置，然后根据角色名来判断角色的立绘，并加载到UI上，外部需要显示对话面板时，就调用这里的ShowDialogPanel函数，这里直接封装了对话面板上数据初始化，根据对话文件名来加载数据 ShowDialog函数中的索引要注意是从1开始，索引为0的字符串保存了这次对话最开始的角色名，用于显示面板第一次加载NPC立绘用的 修改立绘的透明度可以增强视觉表现，当一个角色说话时，就将另外一个角色立绘的透明度调低，这样玩家就不需要通过角色名来分辨这句话是谁说的。当然这个设置立绘透明度的代码有点重复，可以提取成一个函数，使用函数来切换透明度，这里就不这么做了 效果在外部调用ShowDialogPanel函数和ShowDialog函数就可以逐条的显示对话了 角色的透明度改变 角色立绘改变 这样一个对话功能就做好了(人´∀｀)｡ﾟ+"},{"title":"茉子的幻想乡奇遇（一）：PureMVC与主界面","date":"2022-09-12T02:40:32.000Z","url":"/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Apuremvc%E4%B8%8E%E4%B8%BB%E7%95%8C%E9%9D%A2/","tags":[["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"]],"categories":[["茉子的幻想乡奇遇","/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/"]],"content":"使用PureMVC框架和自制面板基类，制作主界面逻辑 茉子的幻想乡奇遇关于这个游戏这是一个2D像素经营、生存类游戏，在游戏中将扮演一个名叫茉子的少女，一边寻找着返回自己的世界的方法，一边耕耘着自己的一片田地，然后与幻想乡的各位女孩邂逅的奇妙冒险 背景某一天，茉子照常起床准备上学，她心想这种日复一日的糟糕日子永远不会到头，在学校里毫无存在感的她没有朋友，每天午餐、放学回家的路上都只有她一个人。“要是能离开这么糟糕的地球Online该有多好啊”，她如此想到，突然，她眼前一黑，睁开眼睛的时候已然是另一番风景… 主界面UI以及UI面板基类思路制作主界面的各个面板，让他们继承自写好的UI面板基类，然后将他们制作成预制件，想要显示面板时，使用同步加载的方式加载UI到Canvas上，隐藏时直接删除掉Canvas上的该面板，对于需要保存/读取数据的面板（如设置面板），使用PureMVC来进行面板和数据的关联 UI面板基类这个基类的作用就是在面板Awake的时候，自动获取面板上的所有控件存入字典，省的去Inspector窗口中拖拽（麻烦，还容易出错） 面板及脚本首先就是制作主界面 面板脚本，重写基类的Awake直接获取自己的控件，获取是为了方便外部访问 然后是游戏存档界面，由于存档可能不止一个，使用Vertical Layout Group组件和Content Size Fitter组件给ScrollView的content做自动布局和自动扩容，游戏存档的数据和UI显示逻辑以后再来写 面板脚本，对于存档按钮的逻辑以后再写 最后是设置界面 面板脚本，UpdateInfo方法提供给外部修改面板控件的数值 PureMVC的使用由于PureMVC通过通知的方式告知各个模块的执行对应的操作，其中通知名十分重要且会重复使用，为了防止通知名写错，就写一个类专门存放通知名，后续有新的通知名直接写进来就可以了 通知名类 音乐数据类及Proxy由于设置面板可以设置音乐/音效数据，而且要将这些数据持久化处理，当然得需要一个数据类 然后给这个数据类添加Proxy，这里使用Json的方式存储读取数据 其中使用的Json管理器，其中有两种读写Json的方法，一个是Unity自带的JsonUtility，一个是第三方的LitJson，需要自己导入LitJson代码 各个面板的Mediator这里给PureMVC中的Mediator添加一个空方法，用于子类获取面板和监听面板控件的事件（在显示面板Command中会用到） 主菜单面板，开始游戏的按钮监听以后再写，主要是跳转逻辑 游戏存档面板 设置面板 Facade和Command在Facade中提供一个单例给没有继承PureMVC的类访问Facade，在此要将命令和通知名绑定并在Facade中注册，提供一个供外部调用的启动游戏方法执行初始化命令 首先是初始化命令，游戏开始的时候，在这里可以初始化信息（注册Proxy之类的），显示主菜单面板 外部调用初始化 显示面板命令，上面在Mediator基类中添加SetView方法的好处就在这里了，由于每个面板的显隐逻辑大差不差，直接提取出一个初始化面板的方法PanelInit，用于注册Mediator和实例化面板，在其中调用SetView，设置自己的ViewComponent和面板上的事件监听 隐藏面板命令 更新设置数据命令，根据notification的body中的内容，是更新音乐数据还是面板上的数据 退出游戏命令 总结使用PureMVC降低了各个模块之间的耦合度，但是它本身使用起来也比较繁琐，小的项目用起来就有点杀鸡用牛刀了，小项目使用单例模式的各个面板管理类（每个面板都有的逻辑泛化到面板积累，比如显隐、单例模式等等）更加轻便好用"},{"title":"利用反射制作PlayerPrefs数据管理类","date":"2022-07-12T08:36:25.000Z","url":"/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%B6%E4%BD%9Cplayerprefs%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B1%BB/","tags":[["Unity","/tags/Unity/"]],"categories":[["功能实现","/categories/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"]],"content":"利用反射机制封装PlayerPrefs，支持更多类型数据存储 利用反射制作PlayerPrefs数据管理类类的框架 实现普通类型存储 实现List数据类型存储 实现Dictionary数据类型存储 实现自定义类型存储 读取普通数据类型 读取List数据类型 读取Dictionary数据类型 读取自定义类型"},{"title":"背包系统","date":"2022-06-18T12:41:18.000Z","url":"/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/","tags":[["Unity","/tags/Unity/"]],"categories":[["功能实现","/categories/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"]],"content":"基于MVC思想，使用数据仓库ScriptableObject存储游戏对象数据 背包UI制作流程首先制作一个背包的UI，对于内部的一个个小格子，在Grid上面添加Grid Layout Group，然后在Grid上添加一个Image命名为Slot，调整为一个小格子的大小，使用Ctrl + D 生成更多的格子，在Grid Layout Group中调整每个Slot，使得刚好覆盖每一格子，在Slot之上添加一个Text，用于显示物品数量,命名为Number，之后在Image上添加Button组件，用于点击物品，最后将Slot保存为一个预制件，删除所有Slot。 编写背包UI开关脚本最开始在Scene中将Bag的Active改为false，让游戏开始时不显示背包UI。 这样可以点击右上角的按钮关闭UI，也可以使用按键开启/关闭UI，使用一个if语句保证isOpen与UI的Active保持同步，则按键就保持了同步，可以让脚本挂载到Canvas同一控制UI。 背包系统整个背包系统的类图 物品使用继承ScriptableObject，将类变为一个可独立于类实例来保存大量数据的数据容器，使用[CreateAssetMenu]特性，可以使用Create实例化一个物品对象。制作一个物品类，用于存储这种类型物品的属性。 背包使用List列表存储物品，依旧使用[CreateAssetMenu]特性，Create一个背包实例。 Scene中的物品（挂载脚本） 将物品显示在UI物品SlotUI控制将之前保存的Slot上挂载一个脚本用于控制UI的参数 将自身的Image和TextMeshPro-Text拖入Inspector 背包整体UI控制将整体控制脚本挂载到Canvas 根据对应字段将对应的对象拖入Inspector 更新显示每当玩家碰到物品时，物品左下角数字需要刷新显示 修改Inventory类，让增加物品时调用刷新背包 显示物品描述点击物品，显示物品描述，修改Slot类 将ItemOnClicked添加到Slot的Button的OnClick()事件上，至此一个最基础的背包就做好了。 物品拖拽的背包系统如果要实现物品拖拽，要将整个背包系统进行重构 重构UI将Grid的透明度改为0，将Slot的Image改为单个小格子，在Grid layout group中调整大小间距，将Slot Apply all，在预制件中将Slot的button删除，重新添加一个button到slot的子节点，将button命名为Item，用于点击拖拽物品，将Item上的Image和子节点的Text删除，Item的Pivot设为中心，再将宽高设为和slot的一样大，将number作为Item的子节点，在Item中新建一个Image，表示物品图片，将图片大小设置略微小于Item大小，让其看起来不那么大，最后将Item中的button组件的Transition字段改为None，当Item的Active为False时，则表示为空格。为了防止Item出现在在不存在的第四排，在Item上增加组件Layou Element,勾选Ignore Layout。 修改Inventory，将初始的ItemList改为18 重构InventoryController类 在Inspector中将emptySlot属性赋值为做好的预制件Slot 重构Slot类 在Inspector中将Slot的Item属性赋值给itemInSlot,将Slot子节点ItemImage赋值给Slot Image属性。 修改Inventory中的RefreshItem方法 在Slot预制件中，将Item的Button组件的OnClick()添加Slot中的ItemOnClicked()实现点击物品出现物品描述。 重构Inventory类 修改修改Inventory中的RefreshItem方法，让其清空列表 实现拖拽拖拽物品由于移动的实际上是Slot中的Item，所以新建一个拖拽脚本，挂载到Slot的Item上，在Item上添加一个组件Canvas Group。 拖拽UI将其挂载到背包UI上 改变背包物品列表中的实际顺序重构Slot类 重构InventoryController类 重构ItemOnDrag类在inspector中对myBag属性赋值 至此，可以拖拽的背包系统就完成了。"},{"title":"游戏存档系统","date":"2022-06-17T08:21:25.000Z","url":"/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/","tags":[["Unity","/tags/Unity/"]],"categories":[["功能实现","/categories/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"]],"content":"数据持久化 存档系统PlayerPrefs“PlayerPrefs”是一个在游戏会话之间存储玩家首选项的类。它可以将字符串、浮点数和整数值存储到用户的平台注册表中。Unity 根据运行应用程序的操作系统以不同的方式存储“PlayerPrefs”数据。 在macOS 上，PlayerPrefs 存储在 中。Unity 对编辑器和独立播放器中的项目使用相同的 .plist 文件。 在 Windows 上，PlayerPrefs 存储在 key 中。 在 Linux 上，PlayerPrefs 存储在 . 在 Windows 应用商店应用上，PlayerPrefs 存储在 中。 在 Windows Phone 8 上，Unity 将 PlayerPrefs 数据存储在应用程序的本地文件夹中。有关详细信息。 在 Android 上，PlayerPrefs 存储在 .Unity 将 PlayerPrefs 数据存储在设备上的“共享首选项”中。C#，JavaScript，Android Java和本机代码都可以访问PlayerPrefs数据。 在WebGL上，Unity使用浏览器的IndexedDB API存储PlayerPrefs数据。 优点：简单易用 缺点： 能直接存储的数据类型有限 数据安全性低 适用范围：适合存储暂时性数据 玩家设定偏好（音量，全屏等） 简单的数据（得分详情） 游戏原型制作时暂时的存储方案 使用PlayerPerfs，数据存储在注册表中 实现 如果玩家没有点击过Save，就点击Load，可以返回一个默认值 PlayerPrefs的拓展 PlayerPrefs只支持int,string,float三种数据类型存取 可以使用JsonUntility来储存更复杂的数据 Unity序列化程序支持的类 → JsonUtility.ToJson() → Json string / PlayerPrefs.SetString() 自定义一个静态类，用于存档 不想将数据一条一条的存取，可以将数据打包成一个类 JSON 优点 便于阅读与编写 适用范围广泛，支持多种主流编程语言 轻量级，易于网络传输与机器解析和生成 缺点 支持的数据类型有限（通过JsonUtility实现的系统） 数据安全性低 适用范围 联网 优秀的网络数据交换载体 云存档 本地存储 非敏感需要大量读取和修改的数据 玩家偏好设置 ToJson 注意：原始类型字段不会被可序列化转换为Json，需要将数据封装在一个类中，并用可序列化特性标记类 只有以下类型可以转换为Json（可以出现在Inspector中）: public 的普通字段（非static , readonly 或 const字段） [SerializeField]特性标记的字段包括（protected 和 private） FormJson FormJsonOverwrite 基于Json的存档系统 PlayerData类 多存档文件名加上时间，即可创建不同时间的多存档 "},{"title":"多线程","date":"2022-06-06T15:33:39.000Z","url":"/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":[["C#高阶","/tags/C-%E9%AB%98%E9%98%B6/"]],"categories":[["C#","/categories/C/"]],"content":"多线程使得并行编程实现，使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。 线程概念​ 对于所有需要等待的操作，例如移动文件，数据库和网络访问都需要一定的时间，此时就可以启动一个新的线程，同时完成其他任务。一个进程的多个线程可以同时运行在单核CPU上或多核CPU的不同内核上。 ​ 线程是程序中独立的指令流。在VS编辑器中输入代码的时候，系统会分析代码，用下划线标注遗漏的分号和其他语法错误，这就是用一个后台线程完成。Word文档需要一个线程等待用户输入，另一个线程进行后台搜索，第三个线程将写入的数据存储在临时文件中。运行在服务器上的应用程序中等待客户请求的线程成为侦听器线程。进程包含资源，如Window句柄，文件系统句柄或其他内核对象。每个进程都分配的虚拟内存。一个进程至少包含一个线程。​ 一个应用程序启动，会启动一个进程（应用程序运行的载体），然后进程启动多个线程。​ 程序 - &gt; 进程 - &gt; 线程 程序：我们写的代码 - 静态概念 进程：正在运行中的程序（正在运行的） ​ 进程是操作系统启动起来​ 线程是在进程中启动起来 Thread类使用Lambda表达式创建新线程 使用结构体传输数据 使用自定义类传输数据 前台线程和后台线程​ 上述方法创建的线程都是前台线程。C#中默认使用前台线程，也可以手动指定为前台线程。 加上语句{IsBackground=false}。 ​ 只有一个前台线程在运行，应用程序的进程就在运行，如果多个前台线程在运行，但是Main 方法结束了，应用程序的进程仍然是运行的，直到所有的前台线程完成其任务为止。 在默认情况下，用Thread类创建的线程是前台线程。线程池中的线程总是后台线程。 在用Thread类创建线程的时候，可以设置IsBackground属性，表示它是一个前台线程还是一 个后台线程。 后台线程加上语句{IsBackground=true} 当Main方法执行完毕之后直接关闭后台线程，所以Console.WriteLine(&quot;Thread +&quot;+Thread.CurrentThread.Name+&quot; end&quot;); 不会被执行。 线程的优先级​ 线程有操作系统调度，一个CPU同一时间只能做一件事情（运行一个线程中的计算任务），当有很多线程需要CPU去执行的时候，线程调度器会根据线程的优先级去判断先去执行哪一 个线程，如果优先级相同的话，就使用一个循环调度规则，逐个执行每个线程。在Thead类中，可以设置Priority属性，以影响线程的基本优先级 。 Priority属性是一个 ThreadPriority枚举定义的一个值。定义的级别有Highest ,AboveNormal,Normal,BelowNormal 和 Lowest， 默认优先级为Normal。 运行可以看到A的执行次数多于B。 线程的状态 获取线程的状态（Running还是Unstarted…），当我们通过调用Thread对象的Start方 法，可以创建线程，但是调用了Start方法之后，新线程不是马上进入Running状态，而是处于Unstarted状态，只有当操作系统的线程调度器选择了要运行的线程，这个线程的状态才会修改为Running状态。我们使用Thread.Sleep()方法可以让当前线程休眠进入 WaitSleepJoin状态。 使用Thread对象的Abort()方法可以停止线程。调用这个方法，会在终止要终止的线程中抛出一个ThreadAbortException类型的异常，我们可以try catch这个异常，然后在线程结 束前做一些清理的工作。 如果需要等待线程的结束，可以调用Thread对象的Join方法，表示把Thread加入进来，暂停当前线程，并把它设置为WaitSleepJoin状态，直到加入的线程完成为止。 线程池​ 创建线程需要时间。如果有不同的小任务要完成,就可以事先创建许多线程 , 在应完成这 些任务时发出请求。 这个线程数最好在需要更多的线程时增加,在需要释放资源时减少。 不需要 自己创建线程池，系统已经有一个ThreadPool类管理线程。 这个类会在需要时增减 池中线程的线程数,直到达到最大的线程数。 池中的最大线程数是可配置的。在双核 CPU 中 ,默认设置为1023个工作线程和 1000个 I/o线程。也可以指定在创建线程池时应立即启 动的最小线程数,以及线程池中可用的最大线程数。 如果有更多的作业要处理,线程池中线程的个数也到了极限,最新的作业就要排队,且必须等待线程完成其任务。 ​ 如果线程池还没有运行,就会创建一个线程池,并启动第一个线程。如果线程池己经在运行,且有一个空闲线程来完成该任务,就把该作业传递给这个线程。 使用线程池需要注意的事项： 线程池中的所有线程都是后台线程 。 如果进程的所有前台线程都结束了,所有的后台线程就会停止。 不能把入池的线程改为前台线程 。 不能给入池的线程设置优先级或名称。 入池的线程只能用于时间较短的任务。 如果线程要一直运行(如 Word的拼写检查器线程),就应使 用Thread类创建一个线程。 任务​ 在.NET4 新的命名空间System.Threading.Tasks包含了类抽象出了线程功能，在后台使用的 ThreadPool进行管理的。任务表示应完成某个单元的工作。这个工作可以在单独的线程中运行，也可以以同步方式启动一个任务。任务也是异步编程中的一种实现方式。 第一种启动任务方式： 使用TaskFactory 第二种启动任务方式： 像新建线程一样启动任务 连续任务当需要一个任务完成后紧接着一个任务时，可以使用连续任务task.ContinueWith(第二个任务) 资源冲突下面代码演示的读写冲突，期望输出的state值是6，结果运行结果有的是5，这是因为当一个线程执行state=5时，别的线程又在执行输出语句，这时就将5输出了。 通过加锁可以防止资源冲突问题，但缺点是执行效率变低，当一个线程执行完毕后才会释放锁，下一个线程才能执行 死锁​ 当用一把锁锁多个资源时，容易发生死锁问题，比如1号线程只需要资源1，2号线程只需要资源2，3号线程需要资源1和2，当1号资源访问资源时，虽然2号资源空闲，但是由于被上锁，导致效率大幅度降低。当某些资源需要多把锁时，容易发生死锁问题，比如一个线程先需要一个1号锁，然后需要一个2号锁，另外一个线程先需要一个2号锁，然后需要一个1号锁，这样程序就会死锁。所以需要分配好锁的顺序，防止死锁的情况发生。"},{"title":"委托、Lambda表达式和事件","date":"2022-03-26T09:39:31.000Z","url":"/C/%E5%A7%94%E6%89%98%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%BA%8B%E4%BB%B6/","tags":[["C#高阶","/tags/C-%E9%AB%98%E9%98%B6/"]],"categories":[["C#","/categories/C/"]],"content":"委托提升了程序的可扩展性，Lambda表达式简化了代码量，增强了代码可读性，事件对委托进行了某些限制 委托引子​ 如果需要把方法当作参数传递的话，就需要使用委托。简单来说委托是一个类型，这个类型可以赋值一个方法的引用。 声明委托​ 在C#中使用一个类分为两个阶段，首先定义这个类，告诉编译器这个类由什么字段和方法组成，然后才实例化这个类。使用委托也是如此，先定义委托，再告诉编译器这个委托可以指向哪些类型的方法，然后创建该委托的实例。 定义委托 使用委托当作方法直接调用 委托类型数组 当作方法的参数使用 Action委托与Func委托所有的委托需要自己定义的话有点冗长，C#系统内置了两种委托 Action委托​ 这种委托引用了一个返回值为void类型的方法，它的参数可有任意个（须在定义时声明参数）。 Func委托​ 这种委托引用了一个有返回值的方法（与Action委托相反），它的参数可有任意个（须在定义时声明参数）。 例子 多播委托​ 前面使用委托都只包含一个方法的调用，但是委托也可以包含方法，这种委托叫做多播委托。使用多播委托就可以按照顺序调用多个方法，多播委托只能得到调用的最后一个方法的结果，一般我们把多播委托的返回类型声明为void（使用Action委托）。 ​ 多播委托包含了一个逐步调用的委托集合，如果通过委托调用的其中一个方法抛出异常，整个迭代就会停止 另外一种调用的方式 匿名方法​ 使用委托，都是先定义一个方法，然后把方法给委托的实例。但还有另外一种使用委托的方式，不用去定义一个方法，而是使用匿名方法（方法没有名字），用于降低代码复杂性。 Lambda表达式​ 如果是匿名方法是减少代码量的第一步，那么使用Lambda表达式就更加精简，它去掉了很多不必要的关键字，还是以上面的例子 ​ 如果一个匿名方法只有一条语句，省去大括号，如果这是一条返回语句，return关键字也可以省略，可以更加精简 访问外部变量 事件​ 事件(event)基于委托，为委托提供了一个发布/订阅机制，我们可以说事件是一种具有特殊签名的委托。事件（Event）是类或对象向其他类或对象通知发生的事情的一种特殊签名的委托.​ 事件的声明：​ public event 委托类型 事件名;事件使用event关键词来声明，他的返回类值是一个委托类型。通常事件的命名，以名字+Event 作为他的名称，在编码中尽量使用规范命名，增加代码可读性。 例子​ 比如在一间大学寝室，其中某个工具人专门给室友带饭，在他的桌上有一个清单，室友可以把自己的名字和需要带的吃的写在这个清单上面，当然如果不需要带饭，也可以划掉自己的名字，当这个工具人买饭的时候，只需要带着清单去，这种处理方式就是订阅/发布机制，这个工具人发布了这个下楼带饭的事件，其他人可以订阅这个事件。 ToolMan类 Roommate类 Program类 这样看似毫无问题，但是却有一个很大的缺陷 在Program类中直接执行以下语句： 会发现当工具人没有下楼，就会触发拿快递，带饭的操作 又或者在在Program类中直接执行以下语句： 这时候，需要在ToolMan类中数据成员：downStairDelegate 的前面加上事件关键字event进行约束 这样就可以避免上述情况发生，只能在类的内部执行，不能在外部执行。 事件与委托的联系和区别 事件是一种特殊的委托，或者说是受限制的委托，是委托一种特殊应用，只能施加+=,-=操作符。二者本质上是一个东西。 event ActionHandler Tick; // 编译成创建一个私有的委托示例, 和施加在其上的add, remove方法. event只允许用add, remove方法来操作，这导致了它不允许在类的外部被直接触发，只能在类的内部适合的时机触发。委托可以在外部被触发，但不建议这么用。 使用中，委托常用来表达回调，事件表达外发的接口。 "},{"title":"正则表达式","date":"2022-03-25T09:38:59.000Z","url":"/C/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":[["C#高阶","/tags/C-%E9%AB%98%E9%98%B6/"]],"categories":[["C#","/categories/C/"]],"content":"对字符串操作的一种逻辑公式 正则表达式概念​ Regular Expression，使用一种数学算法来解决计算机程序中的文本检索、匹配的问题，正则表达式专门用于字符串的语言。很多语言都支持正则表达式。 它可以解决： 检索：通过正则表达式，从字符串中获取我们想要的部分 匹配：判断给定字符串是否符合正则表达式的过滤逻辑 正则表达式表述了一个字符串的书写规则 比如： 判断用户输入的密码是否合法 判断用户输入的邮箱格式是否合法 用户名是否有违禁词 组成​ 由普通字符（字母、数字）和特殊字符（称为元字符）组成的文字模式。该模式描述在查找文字主体时，待匹配的一个或多个字符串。 元字符 元字符 表述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\\n。“\\n”匹配换行符。序列“\\”匹配“\\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式任意次。例如，zo能匹配“z”，“zo”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 .点 匹配除“\\r\\n”之外的任何单个字符。要匹配包括“\\r\\n”在内的任何字符，请使用像“[\\s\\S]”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”或”zood”(此处请谨慎)。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\\b就是匹配位置的）。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。 \\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 \\nml 如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 &lt; &gt; 匹配词（word）的开始（&lt;）和结束（&gt;）。例如正则表达式&lt;the&gt;能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。 ( ) 将 ( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \\1 到\\9 的符号来引用。 | 将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。 + 匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。 ? 匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。 {i} {i,j} 匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字 示例Regex.IsMatch() 校验输入数字\\d 校验输入字母、数字、下划线、汉字\\w Regex.RePlace() 重复描述字符 字符 说明 {n} 匹配前面的字符n次 {n,} 匹配前面的字符n次或更多次 {n,m} 匹配前面的字符n到m次 ? 重复零次或一次 + 重复一次或更多次 * 重复零次或更多次 择一匹配 字符 说明 | 将两个匹配条件进行逻辑“或”(or)运算 分组"},{"title":"关于博客","date":"2022-01-03T11:01:48.000Z","url":"/%E6%97%A5%E5%B8%B8/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/","tags":[["日常","/tags/%E6%97%A5%E5%B8%B8/"]],"categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"关于博客 这里是MoeWolf萌狼，这里将记录我在学习中总结的经验，我将它们写成博客，便于日后查阅和复习。 座右铭 What’s past is prologue.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——莎士比亚 《暴风雨》 "}]