<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="/images/webicon.jpg">
  <title>设计模式 | MoeWolf的博客</title>
  <meta name="author" content="MoeWolf" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="设计模式" />
  
  <meta name="description" content="能够使得代码，承载项目中复杂的业务逻辑，是的代码看起来简洁易懂、易于扩展">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://moewolf.xyz/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="MoeWolf的博客">
<meta property="og:description" content="能够使得代码，承载项目中复杂的业务逻辑，是的代码看起来简洁易懂、易于扩展">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://moewolf.xyz/images/webicon.jpg">
<meta property="article:published_time" content="2023-06-24T11:51:39.000Z">
<meta property="article:modified_time" content="2023-06-24T11:53:57.233Z">
<meta property="article:author" content="MoeWolf">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://moewolf.xyz/images/webicon.jpg">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/holo_banner.png');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/holo_bg.png');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">MoeWolf的博客</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>MoeWolf的博客</h2> <br />
                        <span>𝓦𝓱𝓪𝓽’𝓼 𝓹𝓪𝓼𝓽 𝓲𝓼 𝓹𝓻𝓸𝓵𝓸𝓰𝓾𝓮.</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">设计模式</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2023-06-24</li>
                <li><i class="fa fa-user"></i> 作者 MoeWolf</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~60.32K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1687607637233"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%86%85%E8%81%9A"><span class="toc-number">1.1.</span> <span class="toc-text">高内聚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E8%80%A6%E5%90%88"><span class="toc-number">1.2.</span> <span class="toc-text">低耦合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">1.6.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">1.7.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-number">1.8.</span> <span class="toc-text">迪米特原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">1.9.</span> <span class="toc-text">合成复用原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">创建型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8D%95%E4%BE%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">反射与单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-number">2.3.1.</span> <span class="toc-text">反射与工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.4.1.</span> <span class="toc-text">三种工厂的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">建造者模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">结构型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%BA%94%E7%94%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">游戏开发中的对象池应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">行为型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">职责链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.10.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.11.</span> <span class="toc-text">备忘录模式</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <p>能够使得代码，承载项目中复杂的业务逻辑，是的代码看起来简洁易懂、易于扩展</p>
<span id="more"></span>

<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>高内聚提供了更好的程序<strong>可靠性</strong>、<strong>可读性</strong></p>
<ul>
<li>模块内部元素具有相同特点的相似程度</li>
</ul>
<p>例如</p>
<ul>
<li>Class：新闻管理     Method：新闻查看、新闻更新、新闻删除</li>
<li>Class：用户管理     Method：设置用户名、设置密码、用户注册、用户删除</li>
</ul>
<p>模块：小到一个方法、接口、类，大到一个业务、功能、系统</p>
<ol>
<li>接口：模块的输入和输出</li>
<li>功能：模块实现什么功能</li>
<li>逻辑：模块内部要如何实现要求的功能，以及所需的数据</li>
<li>状态：模块之间调用与被调用关系</li>
</ol>
<p>低内聚会带来什么问题?</p>
<ul>
<li><p>Class：新闻管理     Method：新闻查看、新闻更新、新闻删除、<em>用户管理</em>（低内聚</p>
<p>当要修改用户管理类的时候，需要到新闻管理类中修改相应的逻辑，本不需要重新打程序集的新闻管理类，需要重新打程序集（发版</p>
</li>
</ul>
<p>高内聚要如何设计</p>
<ul>
<li><p>模块A：Cache、IO、IO2、XML、Cache2、XML2等操作，都在模块A中</p>
<p>应该将其拆成三个类，Cache类、IO类、XML类</p>
</li>
</ul>
<h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>低耦合提供了更好的程序<strong>可扩展性</strong>、<strong>可复用性</strong></p>
<ul>
<li>模块之间的依赖程度</li>
</ul>
<p>例如：</p>
<ul>
<li>主板&amp;显卡<ul>
<li>显卡不依赖于某一款主板——低耦合</li>
<li>显卡必须依赖于某一款主板——高耦合</li>
</ul>
</li>
</ul>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则要求在软件系统开发、设计中，一个类只负责一个功能领域相关职责</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开放封闭原则要求一个软件应该对扩展开放，对修改封闭，即在不修改源代码的情况下，完成系统功能的扩展</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则是开闭原则的基础，要求抽象不应该依赖于细节，细节应该依赖于抽象。要面向接口编程，而不面向实现编程</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则是依赖倒置原则的基础，子类可以赋值给父类</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用</p>
<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>一个对象应该尽可能少的与其它对象发生相互作用，能private的尽量private，少用public</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则要求我们尽量使用对象的组合，而非继承来达到复用的目标。将已有的对象纳入新对象中，作为新对象的对象成员来实现的，新对象可以调用自己对象的功能，从而达到复用</p>
<h1 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h1><p>作用于对象的创建，将对象的创建与使用分离</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式应用场景</p>
<ul>
<li>手机应用 + 电脑应用 + windows任务管理器 = 节省资源、提高效率</li>
</ul>
<p>单例模式如何实现？</p>
<ul>
<li>在程序中，如何保证某一个类，有且仅有一个实例？</li>
<li>需要让类不能在外部被new<ol>
<li>构造函数私有化</li>
<li>创建一个唯一对象</li>
</ol>
</li>
</ul>
<p>当我们使用new关键字创建对象时，干了三件事</p>
<ol>
<li>在内存中开辟空间</li>
<li>执行对象的构造函数，创建对象</li>
<li>把内存空间，指向创建的对象</li>
</ol>
<p><strong>饿汉式单例模式（不推荐使用</strong></p>
<p>在没有使用单例的时候，已经存在一个单例在内存中，类似还没有饿肚子，但是饭已经准备好了</p>
<p>不推荐的原因是会造成资源的浪费</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt; 饿汉式单例模式 &lt;/summary&gt;</span><br><span class="line">public class SingleHungry</span><br><span class="line">&#123;</span><br><span class="line">    // 1.构造函数私有化</span><br><span class="line">    private SingleHungry() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.创建一个唯一的对象</span><br><span class="line">    // private 迪米特原则 没有必要暴露给外部的成员 都写成private</span><br><span class="line">    // static 静态成员 保证在内存的唯一性</span><br><span class="line">    // readonly 不允许被修改</span><br><span class="line">    private static readonly SingleHungry instance = new SingleHungry();</span><br><span class="line">    </span><br><span class="line">    // 3.创建一个方法，实现对外提供类唯一对象的能力</span><br><span class="line">    public static SingleHungry Instance =&gt; instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   // 单例测试</span><br><span class="line">class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           SingleHungry single1 = SingleHungry.Instance;</span><br><span class="line">           SingleHungry single2 = SingleHungry.Instance;</span><br><span class="line">           SingleHungry single3 = SingleHungry.Instance;</span><br><span class="line">           // 打印的三个单例的HashCode都是同一个</span><br><span class="line">           Console.WriteLine(single1.GetHashCode());</span><br><span class="line">           Console.WriteLine(single2.GetHashCode());</span><br><span class="line">           Console.WriteLine(single3.GetHashCode());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public class InternalSingleHungry</span><br><span class="line">   &#123;</span><br><span class="line">       public static InternalSingleHungry Instance =&gt; InnerClass.instance;</span><br><span class="line">       </span><br><span class="line">       // 再类的内部，写一个静态类</span><br><span class="line">       public static class InnerClass</span><br><span class="line">       &#123;</span><br><span class="line">           public static readonly InternalSingleHungry instance = new InternalSingleHungry();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>内部静态类在饿汉式的使用</p>
<p>静态内部类，不会跟着外部的<code>InternalSingleHungry</code>一起加载到内存中，只有使用Instance的时候，从才会加载内部类的成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class InternalSingleHungry</span><br><span class="line">&#123;</span><br><span class="line">    public static InternalSingleHungry Instance =&gt; InnerClass.instance;</span><br><span class="line">    </span><br><span class="line">    // 再类的内部，写一个静态类</span><br><span class="line">    public static class InnerClass</span><br><span class="line">    &#123;</span><br><span class="line">        public static readonly InternalSingleHungry instance = new InternalSingleHungry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式单例模式</strong></p>
<p>需要使用对象的时候，才会创建对象，不会造成内存资源的浪费</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   /// &lt;summary&gt; 懒汉式单例模式 &lt;/summary&gt;</span><br><span class="line">   public class SingleLazy</span><br><span class="line">   &#123;</span><br><span class="line">       // 1.私有化构造函数</span><br><span class="line">       private SingleLazy()&#123;&#125;</span><br><span class="line">       </span><br><span class="line">       // 2.声明静态字段，存储唯一的对象实例</span><br><span class="line">       private static SingleLazy instance;</span><br><span class="line">       </span><br><span class="line">       // 3.通过方法，创建对象返回 判断instance为空否</span><br><span class="line">       // 有实例直接返回，没有实例 new了返回</span><br><span class="line">       public static SingleLazy Instance</span><br><span class="line">       &#123;</span><br><span class="line">           get</span><br><span class="line">           &#123;</span><br><span class="line">               if(instance == null)</span><br><span class="line">                   instance = new SingleLazy();</span><br><span class="line">               return instance;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 语法糖</span><br><span class="line">   /// &lt;summary&gt; 懒汉式单例模式 &lt;/summary&gt;</span><br><span class="line">   public class SingleLazy</span><br><span class="line">   &#123;</span><br><span class="line">       // 1.私有化构造函数</span><br><span class="line">       private SingleLazy()&#123;&#125;</span><br><span class="line">       </span><br><span class="line">       // 2.声明静态字段，存储唯一的对象实例</span><br><span class="line">       private static SingleLazy instance;</span><br><span class="line">       </span><br><span class="line">       // 3.通过方法，创建对象返回 判断instance为空否</span><br><span class="line">       // 有实例直接返回，没有实例 new了返回</span><br><span class="line">       public static SingleLazy Instance =&gt; instance ??= new SingleLazy();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>缺点</p>
<p>在单线程中是没有问题的，但是在多线程的中，执行单例创建时，可能导致被多此创建（多线程安全问题</p>
<p>在下面代码中，每个线程中，单例模式都被new了一个实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            new Thread(() =&gt; Console.WriteLine(SingleLazy.Instance.GetHashCode())).Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：加锁</p>
<p>lock关键字是一个语法糖，相当于Monitor.Enter() Monitor.Exit() 互斥锁，用来解决多线程安全问题</p>
<p>如何理解呢？将lock代码块想象成一个箱子，箱子的外面有一把锁，第一个线程执行到此的时候，打开锁执行其中的代码，第二个线程执行到此的时候，打不开这把锁（钥匙被第一个线程拿走了），当第一个线程执行完毕其中的代码时(将钥匙交出)，第二个线程才可以进入，否则其它线程在箱子外等待</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt; 懒汉式单例模式 &lt;/summary&gt;</span><br><span class="line">public class SingleLazy</span><br><span class="line">&#123;</span><br><span class="line">    // 1.私有化构造函数</span><br><span class="line">    private SingleLazy()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 创建锁</span><br><span class="line">    private static object _lock = new object();</span><br><span class="line">    </span><br><span class="line">    // 2.声明静态字段，存储唯一的对象实例</span><br><span class="line">    private static SingleLazy instance;</span><br><span class="line">    </span><br><span class="line">    // 3.通过方法，创建对象返回 判断instance为空否</span><br><span class="line">    // 有实例直接返回，没有实例 new了返回</span><br><span class="line">    public static SingleLazy Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;   </span><br><span class="line">            // 这个是双重锁定 不加这个判断 会消耗系统资源（每一个线程过来，都会和第一个线程抢这把锁</span><br><span class="line">            if (instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (_lock)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance == null)</span><br><span class="line">                        instance = new SingleLazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>指令重排问题</p>
<p>对于new关键字，有时候CPU会使用1 -&gt; 3 -&gt; 2的顺序执行new指令，导致内存指向了一个没有东西的空间</p>
<ol>
<li>在内存中开辟空间</li>
<li>执行对象的构造函数，创建对象</li>
<li>把内存空间，指向创建的对象</li>
</ol>
<ul>
<li><p>如何解决指令重排？</p>
<p>使用<code>volatile</code>关键字，被volatile标记的成员，可以避免指令重排</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static volatile SingleLazy instance;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="反射与单例"><a href="#反射与单例" class="headerlink" title="反射与单例"></a>反射与单例</h3><p>使用反射可以破环以上的单例模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SingleLazy singleLazy1 = SingleLazy.Instance;</span><br><span class="line">        // 通过反射破坏单例 通过反射调用private构造函数</span><br><span class="line">        Type singleType = Type.GetType(&quot;单例模式.SingleLazy&quot;);</span><br><span class="line">        // 获取私有构造函数</span><br><span class="line">        ConstructorInfo[] constructorInfos = </span><br><span class="line">            singleType.GetConstructors((BindingFlags.NonPublic | BindingFlags.Instance));</span><br><span class="line">        </span><br><span class="line">        // 执行构造函数</span><br><span class="line">        SingleLazy singleLazy2 = (SingleLazy) constructorInfos[0].Invoke(null);</span><br><span class="line">        </span><br><span class="line">        // 两个HashCode不一致</span><br><span class="line">        Console.WriteLine(singleLazy1.GetHashCode());</span><br><span class="line">        Console.WriteLine(singleLazy2.GetHashCode());</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个方式可以避免，当instance已经被正常赋值，而且私有构造函数被调用时，可以判断其为反射调用，再此抛异常即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt; 懒汉式单例模式 &lt;/summary&gt;</span><br><span class="line">public class SingleLazy</span><br><span class="line">&#123;</span><br><span class="line">    // 1.私有化构造函数</span><br><span class="line">    private SingleLazy()</span><br><span class="line">    &#123;</span><br><span class="line">        lock (_lock)</span><br><span class="line">        &#123;</span><br><span class="line">            // 如果if被执行，说明有反射调用了这个私有构造函数</span><br><span class="line">            if (instance != null)</span><br><span class="line">                throw new Exception(&quot;单例模式，请不要通过反射调用此私有构造&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建锁</span><br><span class="line">    private static object _lock = new object();</span><br><span class="line">    </span><br><span class="line">    // 2.声明静态字段，存储唯一的对象实例</span><br><span class="line">    private static volatile SingleLazy instance;</span><br><span class="line">    </span><br><span class="line">    // 3.通过方法，创建对象返回 判断instance为空否</span><br><span class="line">    // 有实例直接返回，没有实例 new了返回</span><br><span class="line">    public static SingleLazy Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;   </span><br><span class="line">            // 这个是双重锁定 不加这个判断 会消耗系统资源（每一个线程过来，都会和第一个线程抢这把锁</span><br><span class="line">            if (instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (_lock)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance == null)</span><br><span class="line">                        instance = new SingleLazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果在反射构造之前，instance还是null，则还是会被创建多次，解决方法就是使用标记，在执行构造函数是，将static的标记设置为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 使用静态标记</span><br><span class="line">private static bool isInitialized = false;</span><br><span class="line"></span><br><span class="line">// 1.私有化构造函数</span><br><span class="line">private SingleLazy()</span><br><span class="line">&#123;</span><br><span class="line">    lock (_lock)</span><br><span class="line">    &#123;</span><br><span class="line">        if (isInitialized == false)</span><br><span class="line">        &#123;</span><br><span class="line">            isInitialized = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception(&quot;单例模式，请不要通过反射调用此私有构造&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是反射是可以修改标记位的，在反射中实例一个单例模式后，再修改标记位的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 执行构造函数</span><br><span class="line">SingleLazy singleLazy2 = (SingleLazy) constructorInfos[0].Invoke(null);</span><br><span class="line"></span><br><span class="line">// 修改标记</span><br><span class="line">FieldInfo mark =  singleType.GetField(&quot;isInitialized&quot;, BindingFlags.NonPublic | BindingFlags.Static);</span><br><span class="line"></span><br><span class="line">mark.SetValue(&quot;isInitialized&quot;,false);</span><br><span class="line"></span><br><span class="line">SingleLazy singleLazy3 = (SingleLazy) constructorInfos[0].Invoke(null);</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式又被称作静态工厂方法（Static Factory Method）,不属于23种设计模式之一，是由工厂决定创建出哪一种产品类的实例，是工厂模式中最简单的模式</p>
<ul>
<li>优点<ol>
<li>解决了客户端直接依赖于具体对象的问题，客户端消除了创建对象的责任，仅仅承担使用的责任，实现了对责任的分割</li>
<li>简单工厂实现了代码复用</li>
</ol>
</li>
<li>缺点<ol>
<li>系统扩展困难，一旦加入新的功能，就必须修改工厂的逻辑（增加swith逻辑），这样破坏了开闭原则</li>
<li>简单工厂集合了所有创建对象的逻辑，一旦工厂没有正常工作，整个系统就会出问题</li>
</ol>
</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="简单工厂模式类图"></p>
<p>写一个计算器程序，实现加减乘除功能，下面的代码虽然能完成问题，但是创建对象的过程，和客户端做了强耦合，根据单一职责原则，一个类尽量只干一件事，但是在Main中，干了两件事：输入操作数、根据操作数创建运算对象，这样写也只能在控制台中使用（不能复用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">namespace 简单工厂模式</span><br><span class="line">&#123;</span><br><span class="line">    public class Program</span><br><span class="line">    &#123;</span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">           // 写一个简单的项目，实现计算器的加减乘除</span><br><span class="line">           // 4个对象：加减乘除 依赖倒置原则，面向抽象</span><br><span class="line">           Console.WriteLine(&quot;请输入操作数1&quot;);</span><br><span class="line">           double num1 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">           Console.WriteLine(&quot;请输入操作数2&quot;);</span><br><span class="line">           double num2 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">           Console.WriteLine(&quot;请输入操作符&quot;);</span><br><span class="line">           string oper = Console.ReadLine();</span><br><span class="line">           // 根据Oper的不同，创建不同的计算对象</span><br><span class="line">           ICalculator calculator = null;</span><br><span class="line">           switch (oper)</span><br><span class="line">           &#123;</span><br><span class="line">               case &quot;+&quot;:</span><br><span class="line">                   calculator = new Add();</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;-&quot;:</span><br><span class="line">                   calculator = new Subtract();</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;*&quot;:</span><br><span class="line">                   calculator = new Multiply();</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;/&quot;:</span><br><span class="line">                   calculator = new Divide();</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">           Console.WriteLine(calculator.GetResult(num1, num2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 计算类接口</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public interface ICalculator</span><br><span class="line">    &#123;</span><br><span class="line">        // 方法：能够返回最终计算结果 </span><br><span class="line">        double GetResult(double num1 , double num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Add : ICalculator</span><br><span class="line">    &#123;</span><br><span class="line">        public double GetResult(double num1 , double num2) =&gt; num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Subtract : ICalculator</span><br><span class="line">    &#123;</span><br><span class="line">        public double GetResult(double num1 , double num2) =&gt; num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Multiply : ICalculator</span><br><span class="line">    &#123;</span><br><span class="line">        public double GetResult(double num1 , double num2) =&gt; num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public class Divide : ICalculator</span><br><span class="line">    &#123;</span><br><span class="line">        public double GetResult(double num1 , double num2) =&gt; num1 / num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用简单工厂模式（静态工厂方法</p>
<p>实际上就是把创建对象等待过程，封装到静态方法中，在客户端中调用就行，实现了客户端和创建对象之间的解耦，明确了职责</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       // 写一个简单的项目，实现计算器的加减乘除</span><br><span class="line">       // 4个对象：加减乘除 依赖倒置原则，面向抽象</span><br><span class="line">       Console.WriteLine(&quot;请输入操作数1&quot;);</span><br><span class="line">       double num1 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">       Console.WriteLine(&quot;请输入操作数2&quot;);</span><br><span class="line">       double num2 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">       Console.WriteLine(&quot;请输入操作符&quot;);</span><br><span class="line">       string oper = Console.ReadLine();</span><br><span class="line">       // 根据Oper的不同，创建不同的计算对象</span><br><span class="line">       Console.WriteLine(CalFactory.GetCalculator(oper).GetResult(num1, num2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 计算器工厂</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class CalFactory</span><br><span class="line">&#123;</span><br><span class="line">    // 将创建对象的过程 封装到了静态方法中</span><br><span class="line">    public static ICalculator GetCalculator(string oper)</span><br><span class="line">    &#123;</span><br><span class="line">        ICalculator calculator = null;</span><br><span class="line">        switch (oper)</span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                calculator = new Add();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                calculator = new Subtract();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                calculator = new Multiply();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                calculator = new Divide();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return calculator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li>抽象工厂角色：这是工厂方法的核心，是具体的工厂角色必须实现的接口或者必须继承的抽象类</li>
<li>具体工厂角色：它包含具体业务逻辑有关的代码，由应用程序调用以创建具体的产品对象（加法工厂、除法工厂…）</li>
<li>抽象产品角色：他是具体产品继承的父类，或者接口</li>
<li>具体产品角色：具体工厂创建的对象，也就是该类的实例（加法、减法）</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="工厂方法模式类图"></p>
<p>工厂方法模式：定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化，延迟到子类</p>
<p>根据依赖倒置原则，抽象不应该依赖于细节，CalFactory中创建具体对象，导致抽象依赖细节，所以，我们每一个实例对象都可以写成一个工厂，然后实现工厂接口，不同的工厂，返回不同的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 计算器工厂接口</span><br><span class="line">   /// 将创建对象这件事情，封装成抽象</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public interface ICalFactory</span><br><span class="line">   &#123;</span><br><span class="line">       ICalculator GetCalculator();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 加法工厂</span><br><span class="line">   public class AddFactory : ICalFactory</span><br><span class="line">   &#123;</span><br><span class="line">       public ICalculator GetCalculator() =&gt; new Add();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class SubFactory : ICalFactory</span><br><span class="line">   &#123;</span><br><span class="line">       public ICalculator GetCalculator() =&gt; new Subtract();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class DivideFactory : ICalFactory</span><br><span class="line">   &#123;</span><br><span class="line">       public ICalculator GetCalculator() =&gt; new Divide();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class MultiplyFactory : ICalFactory</span><br><span class="line">   &#123;</span><br><span class="line">       public ICalculator GetCalculator() =&gt; new Multiply();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">   public class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">          // 写一个简单的项目，实现计算器的加减乘除</span><br><span class="line">          // 4个对象：加减乘除 依赖倒置原则，面向抽象</span><br><span class="line">          Console.WriteLine(&quot;请输入操作数1&quot;);</span><br><span class="line">          double num1 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">          Console.WriteLine(&quot;请输入操作数2&quot;);</span><br><span class="line">          double num2 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">          Console.WriteLine(&quot;请输入操作符&quot;);</span><br><span class="line">          string oper = Console.ReadLine();</span><br><span class="line">          // 根据Oper的不同，创建一个创建对象的工厂对象</span><br><span class="line">          ICalFactory calFactory = null;</span><br><span class="line">          // 这里的switch可以通过反射规避</span><br><span class="line">          switch (oper)</span><br><span class="line">          &#123;</span><br><span class="line">              case &quot;+&quot;:</span><br><span class="line">                  calFactory = new AddFactory();</span><br><span class="line">                  break;</span><br><span class="line">              case &quot;-&quot;:</span><br><span class="line">                  calFactory = new SubFactory();</span><br><span class="line">                  break;</span><br><span class="line">              case &quot;*&quot;:</span><br><span class="line">                  calFactory = new MultiplyFactory();</span><br><span class="line">                  break;</span><br><span class="line">              case &quot;/&quot;:</span><br><span class="line">                  calFactory = new DivideFactory();</span><br><span class="line">                  break;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ICalculator calculator = calFactory.GetCalculator();</span><br><span class="line">          Console.WriteLine(calculator.GetResult(num1,num2));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射与工厂"><a href="#反射与工厂" class="headerlink" title="反射与工厂"></a>反射与工厂</h3><p>在第一次出现switch语句时，我们是根据传入的字符串创建不同的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 计算器工厂</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class CalFactory</span><br><span class="line">&#123;</span><br><span class="line">    // 将创建对象的过程 封装到了静态方法中</span><br><span class="line">    // 1.创建对象所有的逻辑，都集合到了一个方法中，风险较高</span><br><span class="line">    // 2.现在是抽象依赖细节 </span><br><span class="line">    public static ICalculator GetCalculator(string oper)</span><br><span class="line">    &#123;</span><br><span class="line">        ICalculator calculator = null;</span><br><span class="line">        switch (oper)</span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                calculator = new Add();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                calculator = new Subtract();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                calculator = new Multiply();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                calculator = new Divide();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return calculator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过工厂方法模式，将这里的switch解决，但是在客户端中，依旧要根据输入的字符串，创建对应的工厂</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       // 写一个简单的项目，实现计算器的加减乘除</span><br><span class="line">       // 4个对象：加减乘除 依赖倒置原则，面向抽象</span><br><span class="line">       Console.WriteLine(&quot;请输入操作数1&quot;);</span><br><span class="line">       double num1 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">       Console.WriteLine(&quot;请输入操作数2&quot;);</span><br><span class="line">       double num2 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">       Console.WriteLine(&quot;请输入操作符&quot;);</span><br><span class="line">       string oper = Console.ReadLine();</span><br><span class="line">       // 根据Oper的不同，创建一个创建对象的工厂对象</span><br><span class="line">       ICalFactory calFactory = null;</span><br><span class="line">       switch (oper)</span><br><span class="line">       &#123;</span><br><span class="line">           case &quot;+&quot;:</span><br><span class="line">               calFactory = new AddFactory();</span><br><span class="line">               break;</span><br><span class="line">           case &quot;-&quot;:</span><br><span class="line">               calFactory = new SubFactory();</span><br><span class="line">               break;</span><br><span class="line">           case &quot;*&quot;:</span><br><span class="line">               calFactory = new MultiplyFactory();</span><br><span class="line">               break;</span><br><span class="line">           case &quot;/&quot;:</span><br><span class="line">               calFactory = new DivideFactory();</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ICalculator calculator = calFactory.GetCalculator();</span><br><span class="line">       Console.WriteLine(calculator.GetResult(num1,num2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么要如何规避switch-case语句呢？</p>
<ul>
<li><p>出现的原因是，描述了一段关系：运算符和具体工厂的对应关系，要解决这个问题，就是换一种方式来实现对应关系</p>
</li>
<li><p>使用Attribute 特性来解决，自定义特效，给四个具体工厂类添加特性，然后创建一个字典，其中存储了用户输入（操作符）和类的映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 计算器工厂接口</span><br><span class="line">/// 将创建对象这件事情，封装成抽象</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public interface ICalFactory</span><br><span class="line">&#123;</span><br><span class="line">    ICalculator GetCalculator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 1.使用Attribute给代码修饰 映射关系</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class Operator2Factory : Attribute</span><br><span class="line">&#123;</span><br><span class="line">    // 因为值是直接写好，加在类上的，不需要set访问器</span><br><span class="line">    public string Oper &#123; get; &#125;</span><br><span class="line">  </span><br><span class="line">    public Operator2Factory(string oper)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Oper = oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 2.程序运行后 拿到描述关系，并且返回相应的对象</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class ReflectionFactory</span><br><span class="line">&#123;</span><br><span class="line">    // 根据用户输入（操作符） 返回一个对象</span><br><span class="line">    Dictionary&lt;string,ICalFactory&gt; calFactoryDic = new Dictionary&lt;string,ICalFactory&gt;();</span><br><span class="line">    </span><br><span class="line">    public ReflectionFactory()</span><br><span class="line">    &#123;</span><br><span class="line">        // 拿到当前正在运行的程序集</span><br><span class="line">        Assembly assembly = Assembly.GetExecutingAssembly();</span><br><span class="line">        // 加了特性的 四个工厂类</span><br><span class="line">        foreach (var itemType in assembly.GetTypes())</span><br><span class="line">        &#123;</span><br><span class="line">            // 这四个类实现了抽象工厂接口</span><br><span class="line">            // 这个表明后面的是否继承 / 实现了前者 但是接口本身也会进false，加个不是接口的判断</span><br><span class="line">            if (typeof(ICalFactory).IsAssignableFrom(itemType) &amp;&amp; !itemType.IsInterface)</span><br><span class="line">            &#123;</span><br><span class="line">                // 拿特性 使用泛型</span><br><span class="line">                Operator2Factory o2f = itemType.GetCustomAttribute&lt;Operator2Factory&gt;();</span><br><span class="line">                // 如果该类的特性中的属性不为null</span><br><span class="line">                if (o2f.Oper != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    // 给字典赋值</span><br><span class="line">                    calFactoryDic[o2f.Oper] = Activator.CreateInstance(itemType) as ICalFactory;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt; 根据用户输入的操作符，在字典中返回一个实例 &lt;/summary&gt;</span><br><span class="line">    public ICalFactory GetCalFactory(string oper)</span><br><span class="line">    &#123;</span><br><span class="line">        if(calFactoryDic.ContainsKey(oper))</span><br><span class="line">            return calFactoryDic[oper];</span><br><span class="line">        else </span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Operator2Factory(&quot;+&quot;)]</span><br><span class="line">public class AddFactory : ICalFactory</span><br><span class="line">&#123;</span><br><span class="line">    public ICalculator GetCalculator() =&gt; new Add();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">[Operator2Factory(&quot;-&quot;)]</span><br><span class="line">public class SubFactory : ICalFactory</span><br><span class="line">&#123;</span><br><span class="line">    public ICalculator GetCalculator() =&gt; new Subtract();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Operator2Factory(&quot;*&quot;)]</span><br><span class="line">public class MultiplyFactory : ICalFactory</span><br><span class="line">&#123;</span><br><span class="line">    public ICalculator GetCalculator() =&gt; new Multiply();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">[Operator2Factory(&quot;/&quot;)]</span><br><span class="line">public class DivideFactory : ICalFactory</span><br><span class="line">&#123;</span><br><span class="line">    public ICalculator GetCalculator() =&gt; new Divide();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       // 写一个简单的项目，实现计算器的加减乘除</span><br><span class="line">       // 4个对象：加减乘除 依赖倒置原则，面向抽象</span><br><span class="line">       Console.WriteLine(&quot;请输入操作数1&quot;);</span><br><span class="line">       double num1 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">       Console.WriteLine(&quot;请输入操作数2&quot;);</span><br><span class="line">       double num2 = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">       Console.WriteLine(&quot;请输入操作符&quot;);</span><br><span class="line">       string oper = Console.ReadLine();</span><br><span class="line">  </span><br><span class="line">       // 执行构造，写入ReflectionFactory的工厂字典</span><br><span class="line">       ReflectionFactory reflectionFactory = new ReflectionFactory();</span><br><span class="line">       // 根据操作符拿到具体工厂</span><br><span class="line">       ICalFactory calFactory = reflectionFactory.GetCalFactory(oper);</span><br><span class="line">       // 根据具体工厂返回具体的计算器</span><br><span class="line">       ICalculator calculator = calFactory.GetCalculator();</span><br><span class="line">  </span><br><span class="line">       Console.WriteLine(calculator.GetResult(num1, num2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂：为了缩减创建子类工厂的数量，不必给每一个产品分配一个工厂类，可以将产品进行分组，每组中的不同产品都由一个工厂类的不同方法来创建</p>
<p>抽象工厂能避免工厂类的无限延伸，他与工厂模式的区别就是，工厂能产生几种对象</p>
<ul>
<li>工厂方法：一个工厂产生一个对象</li>
<li>抽象工厂：一个工厂产生类似（同品牌、同型号）的多种产品（对象）</li>
</ul>
<p>抽象工厂的四个角色</p>
<ul>
<li>抽象工厂角色：这是抽象工厂的核心，是具体的工厂角色必须实现的接口或者抽象类（分组）</li>
<li>具体工厂角色：包含具体业务逻辑的代码，有应用程序调用创建具体产品对象</li>
<li>抽象产品角色：他是具体产品继承的父类或者接口</li>
<li>具体产品角色：具体工厂角色创建的对象，就是该类的实例</li>
</ul>
<p>分别使用简单工厂设计模式 / 工厂方法设计模式实现：创建不同品牌的键盘</p>
<ul>
<li><p>简单工厂</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 创建不同品牌的键盘</span><br><span class="line">   public interface IKeyboard</span><br><span class="line">   &#123;</span><br><span class="line">       void ShowBrand();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   public class DellKeyboard : IKeyboard</span><br><span class="line">   &#123;</span><br><span class="line">       public void ShowBrand() =&gt; Console.WriteLine(&quot;戴尔键盘&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   public class LenovoKeyboard : IKeyboard</span><br><span class="line">   &#123;</span><br><span class="line">       public void ShowBrand() =&gt; Console.WriteLine(&quot;联想键盘&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   public class HPKeyboard : IKeyboard</span><br><span class="line">   &#123;</span><br><span class="line">       public void ShowBrand() =&gt; Console.WriteLine(&quot;惠普键盘&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 键盘简单工厂</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class KeyboardSimpleFactory</span><br><span class="line">   &#123;</span><br><span class="line">       public static IKeyboard GetKeyboard(string brand)</span><br><span class="line">       &#123;</span><br><span class="line">           IKeyboard keyboard = null;</span><br><span class="line">           switch (brand)</span><br><span class="line">           &#123;</span><br><span class="line">               case &quot;Dell&quot;:</span><br><span class="line">                   keyboard = new DellKeyboard();</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;Lenovo&quot;:</span><br><span class="line">                   keyboard = new LenovoKeyboard();</span><br><span class="line">                   break;</span><br><span class="line">               case &quot;HP&quot;:</span><br><span class="line">                   keyboard = new HPKeyboard();</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">           return keyboard;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>工厂方法</p>
<p>将switch换成各种接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 键盘工厂接口</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public interface IKeyboardFactory</span><br><span class="line">&#123;</span><br><span class="line">    IKeyboard GetKeyboard();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">public class DellFactory : IKeyboardFactory</span><br><span class="line">&#123;</span><br><span class="line">    public IKeyboard GetKeyboard() =&gt; new DellKeyboard();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">public class LenovoFactory : IKeyboardFactory</span><br><span class="line">&#123;</span><br><span class="line">    public IKeyboard GetKeyboard() =&gt; new LenovoKeyboard();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">public class HpFactory : IKeyboardFactory</span><br><span class="line">&#123;</span><br><span class="line">    public IKeyboard GetKeyboard() =&gt; new HPKeyboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以发现，每当增加一个产品时，工厂类也会变多（无限延伸）</p>
<p>使用抽象工厂后，进行分组后，只需要两个工厂</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E7%9A%84%E5%AF%BC%E5%85%A5.png" alt="抽象工厂的导入"></p>
<p>抽象工厂类图：</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%9B%BE.png" alt="抽象工厂类图"></p>
<p>场景案例：创建不同品牌下（Dell、HP）的不同产品（鼠标、键盘、主机，也就是产品簇</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        // 根据用户输入拿到什么</span><br><span class="line">        // 先拿到抽象工厂的对象 根据用户输入获取对应的工厂 （这里假设选的戴尔键盘</span><br><span class="line">        IAbstractFactory abstractFactory = new DellFactory();</span><br><span class="line">        IKeyBoard dellKeyboard = abstractFactory.GetKeyBoard();</span><br><span class="line">        dellKeyboard.ShowKeyboardBrand();</span><br><span class="line">        </span><br><span class="line">        IMouse hpMouse = new HPFactory().GetMouse();</span><br><span class="line">        hpMouse.ShowMouseBrand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#region 抽象工厂</span><br><span class="line"></span><br><span class="line">public interface IKeyBoard</span><br><span class="line">&#123;</span><br><span class="line">    void ShowKeyboardBrand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DellKeyBoard : IKeyBoard</span><br><span class="line">&#123;</span><br><span class="line">    public void ShowKeyboardBrand() =&gt; Console.WriteLine(&quot;戴尔键盘&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HPKeyBoard : IKeyBoard</span><br><span class="line">&#123;</span><br><span class="line">    public void ShowKeyboardBrand() =&gt; Console.WriteLine(&quot;惠普键盘&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IMouse</span><br><span class="line">&#123;</span><br><span class="line">    void ShowMouseBrand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DellMouse : IMouse</span><br><span class="line">&#123;</span><br><span class="line">    public void ShowMouseBrand() =&gt; Console.WriteLine(&quot;戴尔鼠标&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HPMouse : IMouse</span><br><span class="line">&#123;</span><br><span class="line">    public void ShowMouseBrand() =&gt; Console.WriteLine(&quot;惠普鼠标&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 抽象工厂</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public interface IAbstractFactory</span><br><span class="line">&#123;</span><br><span class="line">    IKeyBoard GetKeyBoard();</span><br><span class="line">    IMouse GetMouse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DellFactory : IAbstractFactory</span><br><span class="line">&#123;</span><br><span class="line">    public IKeyBoard GetKeyBoard() =&gt; new DellKeyBoard();</span><br><span class="line"></span><br><span class="line">    public IMouse GetMouse() =&gt; new DellMouse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HPFactory : IAbstractFactory</span><br><span class="line">&#123;</span><br><span class="line">    public IKeyBoard GetKeyBoard() =&gt; new HPKeyBoard();</span><br><span class="line"></span><br><span class="line">    public IMouse GetMouse() =&gt; new HPMouse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种工厂的对比"><a href="#三种工厂的对比" class="headerlink" title="三种工厂的对比"></a>三种工厂的对比</h3><ul>
<li>简单工厂：一个工厂类，一个产品抽象类，工厂类创建方法根据传入参数判断，选择创建具体的产品对象</li>
<li>工厂方法：多个工厂类，一个抽象产品类，根据多态创建不同的产品对象，避免了大量的switch-case判断</li>
<li>抽象工厂：多个工厂类，<strong>多个产品抽象类</strong>，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量（多个产品抽象类，分组，使用抽象工厂 </li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能</p>
<ul>
<li>浅拷贝：值类型，创建一个新的，引用类型，复制其引用</li>
<li>深拷贝：值类型、引用类型，都会创建新的</li>
</ul>
<p>常规做法要复制三份简历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Resume</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">    public char Gender &#123; get; set; &#125;</span><br><span class="line">    public string TimeArea &#123; get; set; &#125;</span><br><span class="line">    public string Company &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public void SetInfo(string name, int age, char gender)</span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">        Gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetWorkExperience(string timeArea, string company)</span><br><span class="line">    &#123;</span><br><span class="line">        TimeArea = timeArea;</span><br><span class="line">        Company = company;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void ShowResume()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;&#123;Name&#125; &#123;Age&#125; &#123;Gender&#125;&quot;);</span><br><span class="line">        Console.WriteLine($&quot;&#123;TimeArae&#125; &#123;Company&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样复制实际上是复制引用（浅拷贝 修改其中一个，三个都会被修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Resume resume = new Resume();</span><br><span class="line">    resume.SetInfo(&quot;张三&quot;,28,&#x27;男&#x27;);</span><br><span class="line">    resume.SetWorkExperience(&quot;2018-2022&quot;,&quot;华为&quot;);</span><br><span class="line"></span><br><span class="line">    // 浅拷贝</span><br><span class="line">    Resume resume2 = resume;</span><br><span class="line">    Resume resume3 = resume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能如此修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Resume resume = new Resume();</span><br><span class="line">    resume.SetInfo(&quot;张三&quot;,28,&#x27;男&#x27;);</span><br><span class="line">    resume.SetWorkExperience(&quot;2018-2022&quot;,&quot;华为&quot;);</span><br><span class="line">    </span><br><span class="line">    Resume resume2 = new Resume();</span><br><span class="line">    resume.SetInfo(&quot;张三&quot;,28,&#x27;男&#x27;);</span><br><span class="line">    resume.SetWorkExperience(&quot;2018-2022&quot;,&quot;华为&quot;);</span><br><span class="line">    </span><br><span class="line">    Resume resume3 = new Resume();</span><br><span class="line">    resume.SetInfo(&quot;张三&quot;,28,&#x27;男&#x27;);</span><br><span class="line">    resume.SetWorkExperience(&quot;2018-2022&quot;,&quot;华为&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样十分的消耗性能，通过原型模式，就可以解决这种问题，在ResumePrototype中定义了一个克隆自身的方法</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="原型模式类图"></p>
<p>通过提供的<code>this.MemberwiseClone()</code>方法，和刚刚仅仅传递一个引用完全不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Resume resume = new Resume(&quot;张三&quot;);</span><br><span class="line">        // 拷贝</span><br><span class="line">        Resume resumeClone = (Resume)resume.Clone();</span><br><span class="line">        Console.WriteLine(resumeClone.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class ResumeProtoType</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public ResumeProtoType(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract ResumeProtoType Clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Resume : ResumeProtoType</span><br><span class="line">&#123;</span><br><span class="line">    public Resume(string name) : base(name) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt; 克隆方法 &lt;/summary&gt;</span><br><span class="line">    public override ResumeProtoType Clone()</span><br><span class="line">    &#123;</span><br><span class="line">        // 浅拷贝</span><br><span class="line">        // 值类型成员：全部复制一份，并且到一份新的对象</span><br><span class="line">        // 引用类型：只是复制其引用，不复制其对象</span><br><span class="line">        return this.MemberwiseClone() as ResumeProtoType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是通过上面的方法，我们可以看到，父类ResumeProtoType好像没有什么作用，C#提供了一个接口<code>ICloneable</code> ，实现该接口即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Resume : ICloneable</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">    public char Gender &#123; get; set; &#125;</span><br><span class="line">    public string TimeArea &#123; get; set; &#125;</span><br><span class="line">    public string Company &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public void SetInfo(string name, int age, char gender)</span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">        Gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetWorkExperience(string timeArea, string company)</span><br><span class="line">    &#123;</span><br><span class="line">        TimeArea = timeArea;</span><br><span class="line">        Company = company;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void ShowResume()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;&#123;Name&#125; &#123;Age&#125; &#123;Gender&#125;&quot;);</span><br><span class="line">        Console.WriteLine($&quot;&#123;TimeArae&#125; &#123;Company&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    /// &lt;summary&gt; 实现ICloneable接口 &lt;/summary&gt;</span><br><span class="line">    public object Clone() =&gt; this.MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就是引用类型不会被赋值引用类型对象的数据，而是内存地址，这是因为这个是浅拷贝</p>
<p>现在将TimeArea和Company提取出一个类，让其变成引用类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   public class Resume : ICloneable</span><br><span class="line">   &#123;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">       public int Age &#123; get; set; &#125;</span><br><span class="line">       public char Gender &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">       public WorkExperience WorkExperience &#123; get; set; &#125; = new WorkExperience();</span><br><span class="line">       </span><br><span class="line">       public void SetInfo(string name, int age, char gender)</span><br><span class="line">       &#123;</span><br><span class="line">           Name = name;</span><br><span class="line">           Age = age;</span><br><span class="line">           Gender = gender;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       public void SetWorkExperience(string timeArea,string company)</span><br><span class="line">       &#123;</span><br><span class="line">           WorkExperience.TimeArea = timeArea;</span><br><span class="line">           WorkExperience.Company = company;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public void ShowResume()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine($&quot;&#123;Name&#125; &#123;Age&#125; &#123;Gender&#125;&quot;);</span><br><span class="line">           Console.WriteLine($&quot;&#123;WorkExperience.TimeArea&#125; &#123;WorkExperience.Company&#125;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       /// &lt;summary&gt; 实现ICloneable接口 &lt;/summary&gt;</span><br><span class="line">       public object Clone() =&gt; this.MemberwiseClone();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class WorkExperience</span><br><span class="line">   &#123;</span><br><span class="line">       public string TimeArea &#123; get; set; &#125;</span><br><span class="line">       public string Company &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">   public static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       Resume resume = new Resume();</span><br><span class="line">       resume.SetInfo(&quot;张三&quot;,28,&#x27;男&#x27;);</span><br><span class="line">       resume.SetWorkExperience(&quot;2018-2022&quot;,&quot;华为&quot;);</span><br><span class="line"></span><br><span class="line">       Resume resumeClone = (Resume)resume.Clone();</span><br><span class="line">       resumeClone.ShowResume();</span><br><span class="line">       // 输出后，修改初始的简历</span><br><span class="line">       resume.SetWorkExperience(&quot;2022-2026&quot;, &quot;小米&quot;);</span><br><span class="line">       // 打印结果也会被改变</span><br><span class="line">       resumeClone.ShowResume();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，可以发现修改原本的引用类型成员变量后，克隆后的类中的也被修改了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bug/net6.0/原型模式.exe</span><br><span class="line">张三 28 男</span><br><span class="line">2018-2022 华为</span><br><span class="line">张三 28 男</span><br><span class="line">2022-2026 小米</span><br></pre></td></tr></table></figure>

<p>解决方式，让提取出的类，也实现ICloneable接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class WorkExperience : ICloneable</span><br><span class="line">&#123;</span><br><span class="line">    public string TimeArea &#123; get; set; &#125;</span><br><span class="line">    public string Company &#123; get; set; &#125;</span><br><span class="line">    </span><br><span class="line">    public object Clone() =&gt; this.MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改Resume的实现克隆方法，将值类型（包括特殊引用类型string）和引用类型分离，在克隆中，调用引用类型的克隆方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Resume : ICloneable</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">    public char Gender &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public WorkExperience WorkExperience &#123; get; set; &#125; = new WorkExperience();</span><br><span class="line"></span><br><span class="line">    public Resume() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private Resume(WorkExperience workExperience)</span><br><span class="line">    &#123;</span><br><span class="line">        this.WorkExperience = (WorkExperience)workExperience.Clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt; 实现ICloneable接口 &lt;/summary&gt;</span><br><span class="line">    public object Clone()</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建新对象时，将工作经验这个引用类型也克隆一份</span><br><span class="line">        Resume resume = new Resume(this.WorkExperience);</span><br><span class="line">        resume.Name = Name;</span><br><span class="line">        resume.Age = Age;</span><br><span class="line">        resume.Gender = Gender;</span><br><span class="line">        return resume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种深拷贝时伪深拷贝，每一个引用类型的成员，都需要递归的实现ICloneable接口，这不现实，真正的深拷贝，需要使用反射、序列化来进行</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式：将一个复杂对象的构建和他的表示分离，使得同样的构建过程，可以创建不同的表示</p>
<p>在软件开发中，有时会面临一<strong>个复杂对象</strong>的创建工作，通常由各个部分的子对象用一定的算法构成，由于需求的变化，这个复杂对象的各个部分也经常面临着剧烈的变化，但是将他们组合到一起却相对的稳定</p>
<p>什么是复杂对象</p>
<ul>
<li>子部件较多，没有恰当赋值之前，对象不能当作一个完整的对象或者产品使用（邮件：发件人、收件人、抄送人、主题、内容等</li>
<li>子部件需要按照一定的顺序赋值才有意义，在某个子部件没有赋值之前，另一个子部件就无法赋值（一盘菜：热油、炒菜、放佐料</li>
</ul>
<p>从组装电脑开始</p>
<ol>
<li>学习电脑基础知识：cpu，主板、硬盘、内存、显示器…</li>
<li>各个组成部件的价格、配置、性价比…</li>
<li>如何组装…</li>
<li>如何装系统</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        // 不使用设计模式</span><br><span class="line">        Computer computer = new Computer();</span><br><span class="line">        computer.AddPart(&quot;i5 CPU&quot;);</span><br><span class="line">        computer.AddPart(&quot;1T 硬盘&quot;);</span><br><span class="line">        computer.AddPart(&quot;16 内存&quot;);</span><br><span class="line">        computer.AddPart(&quot;17寸 显示器&quot;);</span><br><span class="line">        computer.AddPart(&quot;Windows 11 操作系统&quot;);</span><br><span class="line">        computer.ShowComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Computer</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt; 表示电脑的零部件集合 &lt;/summary&gt;</span><br><span class="line">    private List&lt;string&gt; partList = new List&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    public void AddPart(string part)</span><br><span class="line">    &#123;</span><br><span class="line">        partList.Add(part);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ShowComputer()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (string part in partList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;正在安装：&#123;part&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写的问题：</p>
<ul>
<li>浪费时间和精力（所有的内容全部都要由客户自己决定</li>
<li>创建对象和客户端强耦合</li>
</ul>
<p>建造者模式就可以解决这个问题，由四个部分组成</p>
<ul>
<li>AbstractBuilder 抽象建造者：为创建一个产品对象的各个部件指定抽象接口，在该接口或者抽象类中，一般提供两种方法，<ul>
<li>各个组件的创建方法</li>
<li>对象返回方法</li>
</ul>
</li>
<li>ConcentrateBuilder 具体建造者：具体建造者实现或者继承抽象建造者，实现各个组件的创建方法和对象方法的方法</li>
<li>Product：被构建的复杂对象，包含多个组件</li>
<li>Director：指挥者负责安排复杂对象的建造顺序</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="建造者模式类图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 抽象创建者</span><br><span class="line">   /// 1.封装创建各个部件的过程</span><br><span class="line">   /// 2.将创建的复杂对象返回</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public interface IBuilderComputer</span><br><span class="line">   &#123;</span><br><span class="line">       void BuildCPU();</span><br><span class="line">       void BuildDisk();</span><br><span class="line">       void BuildMemory();</span><br><span class="line">       void BuildScreen();</span><br><span class="line">       void BuildSystem();</span><br><span class="line">       Computer GetComputer();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 具体建造者——好电脑</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class NiceComputer : IBuilderComputer</span><br><span class="line">   &#123;</span><br><span class="line">       private Computer computer = new Computer();</span><br><span class="line">       </span><br><span class="line">       public void BuildCPU() =&gt; computer.AddPart(&quot;i9 CPU&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildDisk() =&gt; computer.AddPart(&quot;2T 固态&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildMemory() =&gt; computer.AddPart(&quot;64G 内存&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildScreen() =&gt; computer.AddPart(&quot;32寸 显示器&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildSystem() =&gt; computer.AddPart(&quot;Windows 11&quot;);</span><br><span class="line"></span><br><span class="line">       public Computer GetComputer() =&gt; computer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 具体建造者——一般电脑</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class NormalComputer : IBuilderComputer</span><br><span class="line">   &#123;</span><br><span class="line">       private Computer computer = new Computer();</span><br><span class="line">       </span><br><span class="line">       public void BuildCPU() =&gt; computer.AddPart(&quot;i3 CPU&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildDisk() =&gt; computer.AddPart(&quot;128 机械硬盘&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildMemory() =&gt; computer.AddPart(&quot;4G 内存&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildScreen() =&gt; computer.AddPart(&quot;16寸 显示器&quot;);</span><br><span class="line"></span><br><span class="line">       public void BuildSystem() =&gt; computer.AddPart(&quot;Windows XP&quot;);</span><br><span class="line"></span><br><span class="line">       public Computer GetComputer() =&gt; computer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 创建的指挥者</span><br><span class="line">   /// 稳定创建(按照一定的顺序)各个对象的过程</span><br><span class="line">   /// &lt;/summary&gt; </span><br><span class="line">   public class Director</span><br><span class="line">   &#123;</span><br><span class="line">       public void BuildComputer(IBuilderComputer builderComputer)</span><br><span class="line">       &#123;</span><br><span class="line">           builderComputer.BuildCPU();</span><br><span class="line">           builderComputer.BuildDisk();</span><br><span class="line">           builderComputer.BuildMemory();</span><br><span class="line">           builderComputer.BuildScreen();</span><br><span class="line">           builderComputer.BuildSystem();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 被构建的对象——电脑</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class Computer</span><br><span class="line">   &#123;</span><br><span class="line">       /// &lt;summary&gt; 表示电脑的零部件集合 &lt;/summary&gt;</span><br><span class="line">       private List&lt;string&gt; partList = new List&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">       public void AddPart(string part)</span><br><span class="line">       &#123;</span><br><span class="line">           partList.Add(part);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void ShowComputer()</span><br><span class="line">       &#123;</span><br><span class="line">           foreach (string part in partList)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine($&quot;正在安装：&#123;part&#125;&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">   public class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           // 创建了两个创建电脑的建造者</span><br><span class="line">           IBuilderComputer niceBuilder = new NiceComputer();</span><br><span class="line">           IBuilderComputer normalBuilder = new NormalComputer();</span><br><span class="line">           </span><br><span class="line">           // 创建了创建的指挥者</span><br><span class="line">           Director director = new Director();</span><br><span class="line">           </span><br><span class="line">           // 指挥第一个建造者建造对象（按照指挥者的执行顺序</span><br><span class="line">           director.BuildComputer(niceBuilder);</span><br><span class="line">           // 执行了上面的建造完成后，对象就生成了</span><br><span class="line">           niceBuilder.GetComputer().ShowComputer();</span><br><span class="line">           </span><br><span class="line">           director.BuildComputer(normalBuilder);</span><br><span class="line">           normalBuilder.GetComputer().ShowComputer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><p>将类或者对象按照某种布局，通过类与类之间的关系，组成更大的结构</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式：将一个类的接口，转换成客户端希望的另外一个接口</p>
<p>适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
<p>适配器模式的优点：</p>
<ul>
<li>更好的复用性</li>
<li>如果功能已经存在，只是接口不兼容，通过适配器模式就可以让这些功能得到更好的复用</li>
</ul>
<p>适配器模式的缺点：</p>
<ul>
<li>由于Adapter的存在，会提高系统的复杂度（不仅仅是适配器模式，这是整个结构性设计模式的缺点）</li>
</ul>
<p>在软件系统中，我们经常会需要将一些现成的对象放到新的环境中进行使用，但是新的环境要求的接口，是现存的对象所不能满足的，如何利用现有的对象，又能引用新的环境所需要的接口呢</p>
<ul>
<li>摒弃之前的类？重新写？</li>
<li>让以前的类，适配新的环境？</li>
</ul>
<p>适配器模式类图如下</p>
<p>如果用安卓充电线给苹果手机充电，需要一个Type-c转换成苹果头的适配器</p>
<ul>
<li>Adaptee：初始角色（被适配对象），实现了我们想要的功能，但是接口不适配（安卓手机充电线是Adaptee）</li>
<li>Target：目标角色，定义了用户希望的接口（给苹果手机充电是Target）</li>
<li><strong>Adapter：核心，适配器角色，实现了目标接口。实现的方法是，内部包含了一个Adaptee对象，通过调用Adaptee对象的原有方法实现功能（转接头（适配器）是Adapter）</strong></li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="适配器模式类图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           IPhoneCharge phoneCharge = new PhoneChargeAdapter();</span><br><span class="line">           phoneCharge.PhoneCharge();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 安卓充电线——Adaptee</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class AndroidChargeAdapter</span><br><span class="line">   &#123;</span><br><span class="line">       public void AndroidCharge()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;安卓充电线充电&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 苹果充电接口——Target</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public interface IPhoneCharge</span><br><span class="line">   &#123;</span><br><span class="line">       void PhoneCharge();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 适配器角色——Adapter</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class PhoneChargeAdapter : IPhoneCharge</span><br><span class="line">   &#123;</span><br><span class="line">       // 核心：在Adapter中封装了一个Adaptee对象</span><br><span class="line">       // 这个对象才是实现功能的对象</span><br><span class="line">       public AndroidChargeAdapter AndroidChargeAdapter  &#123;get; set;&#125; = new AndroidChargeAdapter();</span><br><span class="line">       </span><br><span class="line">       public void PhoneCharge()</span><br><span class="line">       &#123;</span><br><span class="line">           AndroidChargeAdapter.AndroidCharge();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码类图如下：</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%B5%E6%BA%90%E9%80%82%E9%85%8D%E5%99%A8%E4%BE%8B%E5%AD%90.png" alt="电源适配器例子"></p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比增加子类更为灵活。有效的把类的核心职责和装饰功能分开来解耦</p>
<p><strong>装饰器设计模式应用场景</strong></p>
<p>饮料父类提供了一个Cost方法，返回饮料价格，但是现在需要增加需求，旺饮料中添加一些配料（珍珠、布丁、仙草…</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="装饰器设计模式应用场景"></p>
<ul>
<li><p>面向过程的解决方法：每一种加了配料的饮料，写成一个新的类，让他继承饮料父类（MilkWithBuDing、MilkWithZhenZhu…</p>
<p>这样写会造成子类数量爆炸式增长，每增加一种配料，所有饮料都要多写一种新的子类</p>
<p>而且用户要加两份相同的配料，这种解决方法就完全不能用</p>
<p>所以，继承的方式完全不能使用</p>
</li>
<li><p>使用复合复用原则：让类与类之间通过关联关系来解决</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%8D%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E8%A7%A3%E5%86%B3%E9%85%8D%E6%96%99%E9%97%AE%E9%A2%98.png" alt="复合复用原则解决配料问题"></p>
<p>这种方式也是有一定的问题的，如果添加了新的配料子类，需要修改父类，添加Set配料的方法，然后再Cost中进行计算（只要修改配料，就要修改父类）</p>
<p>所有的问题如下</p>
<ol>
<li>添加新的配料，要改父类</li>
<li>如果父类发生错误，子类全部都会发生错误，耦合性过于高</li>
<li>加入一种饮料——咖啡，咖啡不应该增加配料（但是咖啡继承了父类，会被Set配料</li>
<li>某一配料计算发生错误，会影响所有子类</li>
</ol>
</li>
</ul>
<p>如果现在需要一杯奶茶，加两份布丁、一份珍珠要如何实现</p>
<ul>
<li>Component：定义一个对象接口，可以给这些对象动态的添加职责（这个就是刚刚的饮料父类（抽象类、接口）</li>
<li>ConcreteComponent：定义的具体对象，被添加新的职责（这个就是奶茶、水果茶、苏打茶）</li>
<li><strong>Decorator：核心，继承自Component，将新的功能（职责）装配到具体定义的对象中，引用了一个Component，目的是给他添加新的功能</strong></li>
<li>ConcreteDecorator：具体的装饰器，继承Decorator（各种配料</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="装饰器模式类图"></p>
<p>装饰器模式再饮料中的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 饮料父类</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public abstract class Beverage</span><br><span class="line">&#123;</span><br><span class="line">    // 计算价格的方法</span><br><span class="line">    public abstract double Cost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MilkTea : Beverage</span><br><span class="line">&#123;</span><br><span class="line">    public override double Cost()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;奶茶10元&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitTea : Beverage</span><br><span class="line">&#123;</span><br><span class="line">    public override double Cost()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;水果茶20元&quot;);</span><br><span class="line">        return 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SodaTea : Beverage</span><br><span class="line">&#123;</span><br><span class="line">    public override double Cost()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;苏打饮料30元&quot;);</span><br><span class="line">        return 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 配料装饰器父类</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public abstract class IngredientsDecorator : Beverage</span><br><span class="line">&#123;</span><br><span class="line">    public abstract double Money &#123; get; protected set;&#125;</span><br><span class="line">    // 添加父类引用 通过set赋值 C#的Set充当了装饰器中的SetComponent方法</span><br><span class="line">    public Beverage Beverage &#123; private get; set; &#125;</span><br><span class="line"></span><br><span class="line">    // 返回传入的饮料价格（核心）</span><br><span class="line">    public override double Cost() =&gt; this.Beverage.Cost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 布丁——具体装饰者ConcreteDecorator</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class Pudding : IngredientsDecorator</span><br><span class="line">&#123;</span><br><span class="line">    public override double Money &#123; get; protected set; &#125; = 5;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 核心（类似于递归返回整体价格）</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public override double Cost()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;布丁5元&quot;);</span><br><span class="line">        // 调用之前添加的配料（饮料 的价格，加上自己的价格</span><br><span class="line">        // 才能将整体的的价格返回出来</span><br><span class="line">        return base.Cost() + Money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GrassJelly : IngredientsDecorator</span><br><span class="line">&#123;</span><br><span class="line">    public override double Money &#123; get; protected set; &#125; = 6;</span><br><span class="line">    </span><br><span class="line">    public override double Cost()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;仙草6元&quot;);</span><br><span class="line">        return base.Cost() + Money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Pearl : IngredientsDecorator</span><br><span class="line">&#123;</span><br><span class="line">    public override double Money &#123; get; protected set; &#125; = 7;</span><br><span class="line">    </span><br><span class="line">    public override double Cost()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;珍珠7元&quot;);</span><br><span class="line">        return base.Cost() + Money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用和输出结果输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   public class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           Beverage milkTea = new MilkTea();</span><br><span class="line">           IngredientsDecorator pudding1 = new Pudding();</span><br><span class="line">           IngredientsDecorator pudding2 = new Pudding();</span><br><span class="line">           IngredientsDecorator pearl = new Pearl();</span><br><span class="line">           // 添加一份布丁 (使用Set访问器，等同于SetComponent</span><br><span class="line">           pudding1.Beverage = milkTea;</span><br><span class="line">           // 再添加一份布丁</span><br><span class="line">           pudding2.Beverage = pudding1;</span><br><span class="line">           // 添加一份珍珠</span><br><span class="line">           pearl.Beverage = pudding2;</span><br><span class="line">           // 返回价格</span><br><span class="line">           Console.WriteLine($&quot;总价格：&#123;pearl.Cost()&#125;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">   珍珠7元</span><br><span class="line">   布丁5元</span><br><span class="line">   布丁5元</span><br><span class="line">   奶茶10元</span><br><span class="line">   总价格：27</span><br></pre></td></tr></table></figure>



<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：</p>
<ol>
<li>为其他的对象，提供一种代理</li>
<li>以控制这个对象的访问</li>
</ol>
<p>应用场景：替隔壁班的老王，追自己班的女同学</p>
<ul>
<li>Subject：定义了一个实体对象，和代理他们公用的一些接口，这样，任何使用实体对象的地方都可以使用我们代理的对象（实体对象、代理对象都继承Subject）（老王、自己都有一个送礼物的公用接口</li>
<li>RealSubject：核心实体对象，代笔真正的实体（老王</li>
<li>Proxy：代理，保存了实体的引用，需要调用实体中的一些方法（自己</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="代理模式类图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 公用接口 —— 老王和我都需要送礼物</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public interface ISubject</span><br><span class="line">   &#123;</span><br><span class="line">       void GiveFlower();</span><br><span class="line">       void GiveChocolate();</span><br><span class="line">       void GiveBearDoll();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public class ClassFlower</span><br><span class="line">   &#123;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 被代理对象 —— 老王</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class RealSubject : ISubject</span><br><span class="line">   &#123;</span><br><span class="line">       public ClassFlower ClassFlower &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">       public RealSubject(ClassFlower classFlower)</span><br><span class="line">       &#123;</span><br><span class="line">           this.ClassFlower = classFlower;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void GiveFlower() =&gt; Console.WriteLine($&quot;送花给 &#123;ClassFlower.Name&#125;&quot;);</span><br><span class="line"></span><br><span class="line">       public void GiveChocolate() =&gt;  Console.WriteLine($&quot;送巧克力给 &#123;ClassFlower.Name&#125;&quot;);</span><br><span class="line"></span><br><span class="line">       public void GiveBearDoll() =&gt;  Console.WriteLine($&quot;送小熊给 &#123;ClassFlower.Name&#125;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 代理 —— 帮老王送礼物的我</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class Proxy : ISubject</span><br><span class="line">   &#123;</span><br><span class="line">       public RealSubject RealSubject &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">       public Proxy(RealSubject realSubject)</span><br><span class="line">       &#123;</span><br><span class="line">           this.RealSubject = realSubject;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void GiveFlower() =&gt; RealSubject.GiveFlower();</span><br><span class="line"></span><br><span class="line">       public void GiveChocolate() =&gt; RealSubject.GiveChocolate();</span><br><span class="line"></span><br><span class="line">       public void GiveBearDoll() =&gt; RealSubject.GiveBearDoll();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">   public class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           // 创建班花</span><br><span class="line">           ClassFlower classFlower = new ClassFlower&#123;Name = &quot;小红&quot;&#125;;</span><br><span class="line">           // 创建代理对象 传入被代理的对象实体</span><br><span class="line">           ISubject i = new Proxy(new RealSubject(classFlower));</span><br><span class="line">           // 调用代理方法</span><br><span class="line">           i.GiveFlower();</span><br><span class="line">           i.GiveChocolate();</span><br><span class="line">           i.GiveBearDoll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>安全代理：用来控制真实对象的访问权限</strong></p>
<p>订单系统：订单一旦被创建，只有订单的创建人可以修改订单的数据，其他人则不可以修改相当于，有了一个订单对象，要控制外部对这个订单对象的访问权限，满足条件的可以访问，不满足的不可以访问</p>
<p>订单：订单产品的名称、订单产品的数量、订单创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">    /// 封装了实体对象和代理对象的公用接口 —— ISubject</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public interface IOrder</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 获取订单中产品名称</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        string GetProductName();</span><br><span class="line">        </span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 设置订单中产品的名称</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;productName&quot;&gt;产品名称&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;userName&quot;&gt;用户名称&lt;/param&gt;</span><br><span class="line">        void SetProductName(string productName,string userName);</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 获取订单中产品数量</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        int GetOrderNumber();</span><br><span class="line">        </span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 设置额</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;orderNumber&quot;&gt;产品数量&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;userName&quot;&gt;用户名称&lt;/param&gt;</span><br><span class="line">        void SetOrderNumber(int orderNumber,string userName);</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 获取订单用户</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        string GetOrderUser();</span><br><span class="line">        </span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 设置订单用户</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;orderUserName&quot;&gt;订单用户名称&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;userName&quot;&gt;用户名称&lt;/param&gt;</span><br><span class="line">        void SetOrderUser(string orderUserName, string userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 订单对象</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class RealOrder : IOrder</span><br><span class="line">    &#123;</span><br><span class="line">        public string ProductName &#123; get; set; &#125;</span><br><span class="line">        public int ProductCount &#123; get; set; &#125;</span><br><span class="line">        public string OrderUserName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public RealOrder(string productName, int productCount, string orderUserName)</span><br><span class="line">        &#123;</span><br><span class="line">            this.ProductName = productName;</span><br><span class="line">            this.ProductCount = productCount;</span><br><span class="line">            this.OrderUserName = orderUserName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public string GetProductName() =&gt; ProductName;</span><br><span class="line"></span><br><span class="line">        public void SetProductName(string productName, string userName) =&gt; this.ProductName = productName;</span><br><span class="line"></span><br><span class="line">        public int GetOrderNumber() =&gt; ProductCount;</span><br><span class="line"></span><br><span class="line">        public void SetOrderNumber(int orderNumber, string userName) =&gt; this.ProductCount = orderNumber;</span><br><span class="line"></span><br><span class="line">        public string GetOrderUser() =&gt; OrderUserName;</span><br><span class="line"></span><br><span class="line">        public void SetOrderUser(string orderUserName, string userName) =&gt; this.OrderUserName = orderUserName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 代理对象</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class ProxyOrder : IOrder</span><br><span class="line">    &#123;</span><br><span class="line">        private RealOrder realOrder;</span><br><span class="line">        public ProxyOrder(RealOrder realOrder) =&gt; this.realOrder = realOrder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public void SetProductName(string productName, string userName)</span><br><span class="line">        &#123;</span><br><span class="line">            // 判断权限 有权限可访问 没有权限 不能访问</span><br><span class="line">            // 这里判断用户是否是订单创建的用户 订单创建用户才有权限设置</span><br><span class="line">            if(userName.Equals(this.realOrder.OrderUserName)) </span><br><span class="line">                realOrder.SetProductName(productName, userName);</span><br><span class="line">            else</span><br><span class="line">                Console.WriteLine(&quot;没有权限修改此订单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void SetOrderNumber(int orderNumber, string userName)</span><br><span class="line">        &#123;</span><br><span class="line">            if(userName.Equals(this.realOrder.OrderUserName)) </span><br><span class="line">                realOrder.SetOrderNumber(orderNumber, userName);</span><br><span class="line">            else</span><br><span class="line">                Console.WriteLine(&quot;没有权限修改此订单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void SetOrderUser(string orderUserName, string userName)</span><br><span class="line">        &#123;</span><br><span class="line">            if(userName.Equals(this.realOrder.OrderUserName)) </span><br><span class="line">                realOrder.SetOrderUser(orderUserName, userName);</span><br><span class="line">            else</span><br><span class="line">                Console.WriteLine(&quot;没有权限修改此订单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对查看不做权限控制 </span><br><span class="line">        public string GetProductName() =&gt; this.realOrder.GetProductName();</span><br><span class="line">        public string GetOrderUser() =&gt; this.realOrder.GetOrderUser();</span><br><span class="line">        public int GetOrderNumber() =&gt; this.realOrder.GetOrderNumber();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        IOrder orderProxy = new ProxyOrder(new RealOrder(&quot;笔记本对象&quot;,1,&quot;张三&quot;));</span><br><span class="line">        // 通过李四对张三的订单进行修改 显示没有权限</span><br><span class="line">        orderProxy.SetOrderNumber(200,&quot;李四&quot;);</span><br><span class="line">        // 通过张三自己对订单进行修改 </span><br><span class="line">        orderProxy.SetOrderNumber(300, &quot;张三&quot;);</span><br><span class="line">        Console.WriteLine(orderProxy.GetOrderNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式：隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的统一接口，这个统一接口组合了子系统的多个接口使得子系统更容易被访问和使用</p>
<ul>
<li>优点<ol>
<li>隐藏系统复杂性，让客户端使用系统功能变得简单</li>
<li>实现客户端和子系统的解耦</li>
</ol>
</li>
<li>缺点<ol>
<li>不符合开闭原则</li>
<li>需要客户端使用更多的功能，不仅仅要修改子系统，也必须修改外观层</li>
</ol>
</li>
</ul>
<p>网上流行这一个问题，如何证明你妈是你妈？</p>
<ol>
<li>去派出所开户口证明</li>
<li>去街道办开户籍证明</li>
<li>去医院开生产证明</li>
</ol>
<p>外观模式解决了这种一个人跑到N个地方（子系统）开证明，只需要去市政大厅(统一系统)就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        // 不使用外观模式</span><br><span class="line">        PoliceStation policeStation = new PoliceStation();</span><br><span class="line">        policeStation.GetRegisteredResidence();</span><br><span class="line">        Hospital hospital = new Hospital();</span><br><span class="line">        hospital.GetBirthCertificate();</span><br><span class="line">        </span><br><span class="line">        // 使用外观模式</span><br><span class="line">        MunicipalHall municipalHall = new MunicipalHall();</span><br><span class="line">        municipalHall.GetProof();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 市政大厅 —— 外观模式</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class MunicipalHall</span><br><span class="line">&#123;</span><br><span class="line">    private PoliceStation policeStation;</span><br><span class="line">    private Hospital hospital;</span><br><span class="line"></span><br><span class="line">    public void GetProof()</span><br><span class="line">    &#123;</span><br><span class="line">        this.policeStation.GetRegisteredResidence();</span><br><span class="line">        this.hospital.GetBirthCertificate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PoliceStation</span><br><span class="line">&#123;</span><br><span class="line">    public void GetRegisteredResidence() =&gt; Console.WriteLine(&quot;开户籍证明&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Hospital</span><br><span class="line">&#123;</span><br><span class="line">    public void GetBirthCertificate() =&gt; Console.WriteLine(&quot;开出生证明&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式：将<strong>抽象部分</strong>与它的<strong>实现部分</strong>分离（这句话由于翻译问题存在理解上的歧义），是他们都可以独立的变化</p>
<ul>
<li>优点<ol>
<li>相对于静态继承，极大减少了子类个数，从而降低了管理和维护成本</li>
<li>提高了系统的可扩展性，在两个变化的维度中，任意扩展一个维度，都不需要修改原有系统，符合开闭原则。<strong>就像一座桥，把两个变化的维度连接了起来</strong></li>
</ol>
</li>
<li>缺点<ol>
<li>引入了会增加系统理解的设计难度，由于组合 / 聚合关系建立在抽象层，要求开发者针对抽象进行设计与编程</li>
<li>桥接模式要求正确的识别系统中两个独立的变化维度，要求开发者对编程思想有较高的要求</li>
</ol>
</li>
</ul>
<p>桥接模式就是合成复用原则的具体落地：将已有的对象纳入新对象中，作为新对象的对象成员来实现的，新对象可以调用自己对象的功能，从而达到复用</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E6%B1%BD%E8%BD%A6%E6%A1%88%E4%BE%8B.png" alt="合成复用原则汽车案例"></p>
<ul>
<li>Abstract：抽象部分就是上图中的汽车类</li>
<li>Implementor：就是上面图中的Color接口</li>
</ul>
<p>这样使得抽象部分和实现部分都可以独立的改变，因为他们只是关联关系</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="桥接模式类图"></p>
<p>案例：把不同类型的汽车和不同颜色组合，但是不产生大量的类</p>
<p>按照合成复用原则：将变化的维度分开</p>
<p>这里将颜色分离（实现）汽车类型（抽象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 颜色 —— Implementor</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public interface IColor</span><br><span class="line">   &#123;</span><br><span class="line">       string ShowColor();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public class Red : IColor</span><br><span class="line">   &#123;</span><br><span class="line">       public string ShowColor() =&gt; &quot;Red&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class Green : IColor</span><br><span class="line">   &#123;</span><br><span class="line">       public string ShowColor() =&gt; &quot;Green&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class Yellow : IColor</span><br><span class="line">   &#123;</span><br><span class="line">       public string ShowColor() =&gt; &quot;Yellow&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 不同类型的车 —— Abstract</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public abstract class Car</span><br><span class="line">   &#123;</span><br><span class="line">       // 在抽象的类中需要有一个对实现的引用</span><br><span class="line">       // 字段、构造函数、属性、函数中以参数传递都可以 实现这个引用</span><br><span class="line">       public abstract void Move(IColor color);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class GasCar : Car</span><br><span class="line">   &#123;</span><br><span class="line">       public override void Move(IColor color)</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine($&quot;&#123;color&#125; 颜色的汽油车在跑&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class ElectricCar : Car</span><br><span class="line">   &#123;</span><br><span class="line">       public override void Move(IColor color)</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine($&quot;&#123;color&#125; 颜色的电车在跑&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           Car gasCar = new GasCar();</span><br><span class="line">           gasCar.Move(new Green());</span><br><span class="line">           Car electricCar = new ElectricCar();</span><br><span class="line">           electricCar.Move(new Red());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这样以后，加一种颜色只需要加一个类，同样的，添加一种类型汽车，也只需要增加一个类</p>
<p>相比静态继承，增加一个颜色，需要增加一个（新颜色的汽车、新颜色的电车…）大大减少了子类的数量</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式：可以使用它将对象组合成树状结构，并且能够像独立对象一样使用他们</p>
<p>需求，某公司开发一个部门-人员管理系统，要求可以对部门和员工进行灵活的增加和移除，并且可以展示部门和部门内部的员工</p>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png" alt="组合模式的层级结构"></p>
<p>使用何种设计，才能实现这种树状结构？</p>
<ul>
<li>Component：组合模式的根节点，可以是接口、抽象类、普通类，该类定义了子类中所有的共性内容，并且还定义了用于访问和管理子类的方法（相当于公司<ul>
<li>使用Add/Remove进行增减部门、员工</li>
<li>使用Display，传入depth，显示第几层深度</li>
</ul>
</li>
<li>Leaf：组合中的叶子节点，也是最末端的节点，该节点下，不会再有子节点（相当于员工</li>
<li>Composite：非叶子节点，它的作用是存储子部件，并且在Composite中，实现了对子部件的相关操作（相当于部门</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="组合模式类图."></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">    /// 定义了子类中共有的成员</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public abstract class Component</span><br><span class="line">    &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public Component(string name) =&gt; Name = name;</span><br><span class="line"></span><br><span class="line">        public abstract void Add(Component component);</span><br><span class="line">        public abstract void Remove(Component component);</span><br><span class="line">        public abstract void Display(int depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 部门类 —— Composite</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class DepartmentComposite : Component</span><br><span class="line">    &#123;</span><br><span class="line">        public List&lt;Component&gt; componentList = new List&lt;Component&gt;();</span><br><span class="line">        public DepartmentComposite(string name) : base(name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        public override void Add(Component component) =&gt; componentList.Add(component);</span><br><span class="line"></span><br><span class="line">        public override void Remove(Component component) =&gt; componentList.Remove(component);</span><br><span class="line"></span><br><span class="line">        public override void Display(int depth)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(new string(&#x27;-&#x27;, depth) + Name);</span><br><span class="line"></span><br><span class="line">            foreach (Component component in componentList)</span><br><span class="line">            &#123;</span><br><span class="line">                // 运用了递归的思想 多输出几个 ----</span><br><span class="line">                component.Display(depth + 4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 员工 —— leaf节点</span><br><span class="line">    /// leaf无法添加子集</span><br><span class="line">    /// 所以Add / Remove 只能空实现</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class EmployeeLeaf : Component</span><br><span class="line">    &#123;</span><br><span class="line">        public EmployeeLeaf(string name) : base(name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        public override void Add(Component component) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        public override void Remove(Component component) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        public override void Display(int depth)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(new string(&#x27;-&#x27;,depth) + Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 使用</span><br><span class="line">    public class Program</span><br><span class="line">    &#123;</span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            // Component 根节点 公司</span><br><span class="line">            // Component 是一个抽象类，只能用Department 来代替</span><br><span class="line">            Component company  = new DepartmentComposite(&quot;Cygames&quot;);</span><br><span class="line">            // Composite 树枝 部门</span><br><span class="line">            Component dep = new DepartmentComposite(&quot;开发部&quot;);</span><br><span class="line">            // Leaf 树叶 员工           </span><br><span class="line">            Component emp = new EmployeeLeaf(&quot;木村唯人&quot;);</span><br><span class="line">            </span><br><span class="line">            // 通过组合的方式形成树状结构</span><br><span class="line">            company.Add(dep);</span><br><span class="line">            dep.Add(emp);</span><br><span class="line">            </span><br><span class="line">            // 递归打印</span><br><span class="line">            company.Display(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>当系统中需要大量使用某些相同或者相似的对象，这些对象会消耗大量的资源，<strong>并且这些对象剔除外部状态后可以通过同一个对象来替代（和单例模式的不同之处</strong>，这时，我们可以使用享元模式来解决</p>
<p>场景：刚开始做PC版电商网站，过了一段时间后需要做小程序版的电商网站，再过了一段时间需要做一个APP版的电商网站</p>
<ul>
<li>解决方案1：将代码复制粘贴，根据不同用户的需求，定制化的修改、开发<ul>
<li>问题1：针对每个用户网站，都需要创建新的服务器资源、数据库资源，造成了资源的浪费</li>
<li>问题2：迭代的成本巨大，做了一个新的功能，需要迭代到每一个版本上去</li>
</ul>
</li>
<li>解决方案2：<ol>
<li>整合到一个网站中，共享其相关的代码和数据，对于硬件资源可以大大缩减其使用量</li>
<li>对于代码，由于核心代码和数据都是共享一份实例，提高了代码的维护性和扩展性</li>
</ol>
</li>
</ul>
<p>和单例模式的区别：</p>
<ul>
<li>使用共享单车来描述这个问题，单例模式的解决方式是全城只有一辆共享单车，<strong>单例对象有且只有一个</strong></li>
<li>共享单车使用了池（存放点）的概念，<strong>享元模式对象可能存在多个</strong>（也是为了避免浪费过多资源的初衷</li>
</ul>
<p>什么是内部状态和外部状态：拿一部视频、共享单车举例</p>
<ul>
<li>内部状态：对象内部不受环境改变的部分作为内部状态（视频资源本身、共享单车本身（锁定、骑行状态，二维码）</li>
<li>外部状态：随着环境的变化而变化的部分（视频的上传者、骑共享单车的人</li>
</ul>
<p>池技术：运用<strong>共享技术</strong>有效的<strong>支持大量细粒度</strong>的对象</p>
<ul>
<li>字符串拘留池（两个字符串内容相同，俩字符串会指向同一个内存）</li>
<li>数据库连接池（保持和数据库的长链接</li>
<li>线程池</li>
<li>对象池</li>
</ul>
<p>享元模式的部分</p>
<ul>
<li>Flyweight：所有具体享元类的父类或者接口，封装了一些接口</li>
<li>ConcreteFlyweight：实现接口，并对内部状态增加存储空间</li>
<li>FlyweightFactory：用来创建和管理享元对象的工厂（当用户请求一个享元对象时，提供一个已经创建的或者创建一个新的对象</li>
</ul>
<p><img src="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="享元模式类图"></p>
<p>共享单车案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 共享单车享元父类——Flyweight</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">public abstract class BikeFlyweight</span><br><span class="line">   &#123;</span><br><span class="line">       // 内部状态 （不受外部变化而变化</span><br><span class="line">       public int BikeID &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">       // State 0: 锁定 1: 骑行中</span><br><span class="line">       public int State &#123; get; set; &#125; = 0;</span><br><span class="line"></span><br><span class="line">       public abstract void RideBike(string userName);</span><br><span class="line"></span><br><span class="line">       public abstract void BackBike(string userName);</span><br><span class="line"></span><br><span class="line">       // 外部状态 —— 使用的用户</span><br><span class="line">       public string UserName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 小黄车——ConcreteFlyweight</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class YellowBike : BikeFlyweight</span><br><span class="line">   &#123;</span><br><span class="line">       public YellowBike(int bikeID)</span><br><span class="line">       &#123;</span><br><span class="line">           this.BikeID = bikeID;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public override void RideBike(string userName)</span><br><span class="line">       &#123;</span><br><span class="line">           this.State = 1;</span><br><span class="line">           Console.WriteLine($&quot;&#123;userName&#125; 正在骑行ID是 &#123;this.BikeID&#125; 的自行车&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public override void BackBike(string userName)</span><br><span class="line">       &#123;</span><br><span class="line">           this.State = 0;</span><br><span class="line">           Console.WriteLine($&quot;&#123;userName&#125; 归还了ID是 &#123;this.BikeID&#125; 的自行车&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 客户端使用的享元工厂</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   public class BikeFlyweightFactory</span><br><span class="line">   &#123;</span><br><span class="line">       private List&lt;BikeFlyweight&gt; bikePool = new List&lt;BikeFlyweight&gt;();</span><br><span class="line"></span><br><span class="line">       public BikeFlyweightFactory()</span><br><span class="line">       &#123;</span><br><span class="line">           // 预先给一些共享单车</span><br><span class="line">           for (int i = 0; i &lt; 3; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               bikePool.Add(new YellowBike(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public BikeFlyweight GetBike()</span><br><span class="line">       &#123;</span><br><span class="line">           foreach (var bike in bikePool)</span><br><span class="line">           &#123;</span><br><span class="line">               // 返回没有使用中的单车</span><br><span class="line">               if (bike.State.Equals(0))</span><br><span class="line">               &#123;</span><br><span class="line">                   return bike;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用和输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建享元工厂对象</span><br><span class="line">        BikeFlyweightFactory factory = new BikeFlyweightFactory();</span><br><span class="line">        BikeFlyweight bike = factory.GetBike();</span><br><span class="line">        bike.RideBike(&quot;张三&quot;);</span><br><span class="line">        // 归还了之后，李四拿到的是归还的这辆</span><br><span class="line">        bike.BackBike(&quot;张三&quot;);</span><br><span class="line">        BikeFlyweight bike2 = factory.GetBike();</span><br><span class="line">        bike2.RideBike(&quot;李四&quot;);</span><br><span class="line">        BikeFlyweight bike3 = factory.GetBike();</span><br><span class="line">        bike3.RideBike(&quot;王五&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">张三 正在骑行ID是 0 的自行车</span><br><span class="line">张三 归还了ID是 0 的自行车</span><br><span class="line">李四 正在骑行ID是 0 的自行车</span><br><span class="line">王五 正在骑行ID是 1 的自行车</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0。</span><br></pre></td></tr></table></figure>



<h3 id="游戏开发中的对象池应用"><a href="#游戏开发中的对象池应用" class="headerlink" title="游戏开发中的对象池应用"></a>游戏开发中的对象池应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 池子中的一列数据</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class PoolData</span><br><span class="line">&#123;</span><br><span class="line">    //对象挂载的父节点</span><br><span class="line">    public GameObject parentObj;</span><br><span class="line"></span><br><span class="line">    //对象的容器</span><br><span class="line">    public List&lt;GameObject&gt; poolList;</span><br><span class="line"></span><br><span class="line">    public PoolData(GameObject obj, GameObject poolObj)</span><br><span class="line">    &#123;</span><br><span class="line">        //抽屉父对象</span><br><span class="line">        parentObj = new GameObject(obj.name);</span><br><span class="line">        parentObj.transform.parent = poolObj.transform;</span><br><span class="line">        //放入池</span><br><span class="line">        poolList = new List&lt;GameObject&gt;();</span><br><span class="line">        PushObj(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 往抽屉放</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void PushObj(GameObject obj)</span><br><span class="line">    &#123;</span><br><span class="line">        //将物体失活</span><br><span class="line">        obj.SetActive(false);</span><br><span class="line">        //存入抽屉</span><br><span class="line">        poolList.Add(obj);</span><br><span class="line">        //设置父对象</span><br><span class="line">        obj.transform.parent = parentObj.transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 从抽屉取</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public GameObject GetObj()</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject obj = null;</span><br><span class="line">        //让对象等于抽屉中的第一个对象（索引为0）</span><br><span class="line">        obj = poolList[0];</span><br><span class="line">        //拿取后，移除列表（抽屉）索引为0的</span><br><span class="line">        poolList.RemoveAt(0);</span><br><span class="line">        //将物体激活</span><br><span class="line">        obj.SetActive(true);</span><br><span class="line">        //解除父对象关系</span><br><span class="line">        obj.transform.parent = null;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 缓存池模块</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class PoolMgr</span><br><span class="line">&#123;</span><br><span class="line">    private static PoolMgr instance;</span><br><span class="line">    public static PoolMgr Instance =&gt; instance ??= new PoolMgr();</span><br><span class="line">    //缓存池容器</span><br><span class="line">    public Dictionary&lt;string, PoolData&gt; poolDic = new Dictionary&lt;string, PoolData&gt;();</span><br><span class="line"></span><br><span class="line">    private GameObject poolObj;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 拿取对象</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;name&quot;&gt;对象的预制件路径名（Resources）&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public void GetObj(string name,UnityAction&lt;GameObject&gt; callback)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject obj = null;</span><br><span class="line">        //当字典中有该类对象（抽屉），并且该类对象的列表中还有该对象（抽屉中还有衣服）</span><br><span class="line">        if (poolDic.ContainsKey(name) &amp;&amp; poolDic[name].poolList.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            callback(poolDic[name].GetObj());</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //通过异步加载资源 创建对象给外部使用</span><br><span class="line">            ResMgr.Instance.LoadAsync&lt;GameObject&gt;(name, (obj) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                obj.name = name;</span><br><span class="line">            &#125;);</span><br><span class="line">            // //未继承Mono</span><br><span class="line">            // obj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));</span><br><span class="line">            // //将对象名字改为对应资源的名字，方便Push</span><br><span class="line">            // obj.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 将不用的对象放回缓存池</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void PushObj(string name,GameObject obj)</span><br><span class="line">    &#123;</span><br><span class="line">        //没有池则创建</span><br><span class="line">        if (poolObj == null)</span><br><span class="line">            poolObj = new GameObject(&quot;ObjectPool&quot;);</span><br><span class="line">        //有抽屉</span><br><span class="line">        if (poolDic.ContainsKey(name))</span><br><span class="line">            poolDic[name].PushObj(obj);</span><br><span class="line">        //没有抽屉</span><br><span class="line">        else</span><br><span class="line">            poolDic.Add(name,new PoolData(obj,poolObj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 清空缓存池，用于场景切换</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void Clear()</span><br><span class="line">    &#123;</span><br><span class="line">        poolDic.Clear();</span><br><span class="line">        poolObj = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><p>作用于类或者对象之间互相协作完成，单个对象无法单独完成的任务，以及如何分配职责</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://moewolf.xyz/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://moewolf.xyz/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/";
            const title         = "「设计模式」";
            const excerpt       = `能够使得代码，承载项目中复杂的业务逻辑，是的代码看起来简洁易懂、易于扩展`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2023-06-24</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 茉子的幻想乡奇遇（七）：场景切换和农田恢复" href="/茉子的幻想乡奇遇/茉子的幻想乡奇遇（七）：场景切换和农田恢复/">&lt; 上一篇</a>
            </div>
            
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/holo_avatar.png" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">生如夏花之绚烂</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%86%85%E8%81%9A"><span class="toc-text">高内聚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E8%80%A6%E5%90%88"><span class="toc-text">低耦合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-text">迪米特原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-text">合成复用原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">创建型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8D%95%E4%BE%8B"><span class="toc-text">反射与单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-text">反射与工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">三种工厂的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">建造者模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">结构型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%BA%94%E7%94%A8"><span class="toc-text">游戏开发中的对象池应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">行为型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">职责链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">备忘录模式</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C#</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">功能实现</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/">茉子的幻想乡奇遇</a><span class="category-list-count">7</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/C-%E9%AB%98%E9%98%B6/" style="font-size: 0.7em;">C#高阶</a> <a href="/tags/Unity/" style="font-size: 0.7em;">Unity</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" style="font-size: 0.8em;">开发日志</a> <a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 0.6em;">日常</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.6em;">设计模式</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa  fa-book"></i> 设计模式</a>
            
          
        
          
          
            <a class="list-group-item" href="/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%92%8C%E5%86%9C%E7%94%B0%E6%81%A2%E5%A4%8D/"><i class="fa  fa-book"></i> 茉子的幻想乡奇遇（七）：场景切换和农田恢复</a>
            
          
        
          
          
            <a class="list-group-item" href="/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E7%A7%8D%E7%94%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"><i class="fa  fa-book"></i> 茉子的幻想乡奇遇（六）：种田功能的实现</a>
            
          
        
          
          
            <a class="list-group-item" href="/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%8E%A9%E5%AE%B6%E6%8E%A7%E5%88%B6%E5%92%8C2d%E6%B7%B7%E5%90%88%E6%A0%91/"><i class="fa  fa-book"></i> 茉子的幻想乡奇遇（五）：玩家控制和2D混合树</a>
            
          
        
          
          
            <a class="list-group-item" href="/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87/%E8%8C%89%E5%AD%90%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%E5%A5%87%E9%81%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9C%A8%E7%AE%B1%E5%92%8C%E8%83%8C%E5%8C%85%E7%89%A9%E5%93%81%E7%9A%84%E4%BA%92%E6%8D%A2/"><i class="fa  fa-book"></i> 茉子的幻想乡奇遇（四）：木箱和背包物品的互换</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/LittleWolfHouse"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Dai-MoeWolf"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 MoeWolf的博客 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by MoeWolf.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>




    <script defer src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>